# ëª…ì„¸ì„œ(2) ìŠ¤ì¼ˆë ˆí†¤ í”„ë¡œì íŠ¸ (1)

---

#### ëª©ì°¨

1. [gps_parser.py](#1-gps_parserpy)
    - [To Do](#1-1-to-do)
    - [Source Code](#1-2-ì½”ë“œ)
    - [ì‹¤í–‰ ê²°ê³¼](#1-3-ê²°ê³¼)
2. [gpsimu_parser.py](#2-gpsimu_parserpy)
    - [To Do](#2-1-to-do)
    - [Source Code](#2-2-ì½”ë“œ)
    - [ì‹¤í–‰ ê²°ê³¼](#2-3-ê²°ê³¼)
3. [tf_pub.py](#3-tf_pubpy)
4. [mgeo.py & mgeo_pub.py](#4-mgeo--mgeo_pub)
    - [mgeo.py ì½”ë“œ](#4-1-mgeo-ì½”ë“œ)
    - [mgeo_pub.py ì½”ë“œ](#4-2-mgeo_pub-ì½”ë“œ)
    - [ì‹œê°í™”](#4-3-ì‹œê°í™”)
    - [ì‹¤í–‰ ê²°ê³¼](#4-4-ê²°ê³¼)
    

---

## 1. gps_parser.py

#### 1-1) To do

```python
#TODO: (0) pyproj ë¼ì´ë¸ŒëŸ¬ë¦¬ Import [ pip install pyproj ]
#TODO: (1) ë³€í™˜ í•˜ê³ ì í•˜ëŠ” ì¢Œí‘œê³„ë¥¼ ì„ ì–¸
        '''
        # GPS ì„¼ì„œì—ì„œ ìˆ˜ì‹ ë˜ëŠ” ìœ„ë„, ê²½ë„ ë°ì´í„°ë¥¼ UTM ì¢Œí‘œë£Œ ë³€í™˜ í•˜ê¸° ìœ„í•œ ì˜ˆì œì´ë‹¤.
        # í•´ë‹¹ ì˜ˆì œëŠ” WGS84 ì¢Œí‘œê³„ì—ì„œ UTM ì¢Œí‘œê³„ë¡œì˜ ë³€í™˜ì„ ì§„í–‰í•œë‹¤.
        # ì‹œë®¬ë ˆì´í„° K-City Map ì˜ ê²½ìš° UTM ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•˜ë©° ì‹¤ì œ ì§€ë„ ìƒ ìœ„ì¹˜ëŠ” UTM ì¢Œí‘œê³„ì˜ 52 Zone ì— ì¡´ì¬í•œë‹¤.
        # ë§µ ì¢Œí‘œê³„ëŠ” m ë‹¨ìœ„ë¥¼ ì‚¬ìš©í•œë‹¤.
        # ì•„ë˜ ì£¼ì†Œì˜ ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ Ptoj ì˜ ì‚¬ìš© ë°©ë²•ì„ í™•ì¸í•œë‹¤.
        # https://pyproj4.github.io/pyproj/stable/api/proj.html
        # " proj= , zone= , ellps =  , preserve_units = "
        self.proj_UTM = Proj( ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ë³€ìˆ˜ ì…ë ¥ )

        '''
 #TODO: (2) ì‹œë®¬ë ˆì´í„°ì—ì„œ GPS ë°ì´í„°ë¥¼ ë°›ì•„ì˜¤ëŠ” Callback í•¨ìˆ˜ ìƒì„±
    def navsat_callback(self, gps_msg):
        '''
        GPS ì„¼ì„œì—ì„œ ìˆ˜ì‹ ë˜ëŠ” ìœ„ë„ ê²½ë„ ë°ì´í„°ë¥¼ í™•ì¸í•œë‹¤.
        self.lat = 
        self.lon = 

        '''
        self.convertLL2UTM()

        utm_msg = Float32MultiArray()

        #TODO: (4) ìœ„ë„ ê²½ë„ ë°ì´í„°ì™€ ë³€í™˜í•œ UTM ì¢Œí‘œë¥¼ í„°ë¯¸ë„ ì°½ì— ì¶œë ¥ í•˜ì—¬ í™•ì¸
        '''
        UTM ìœ¼ë¡œ ë³€í™˜ ëœ ì¢Œí‘œ ë°ì´í„°ì™€ ìœ„ë„ ê²½ë„ ë°ì´í„°ë¥¼ í„°ë¯¸ë„ ì°½ì— ì¶œë ¥ë˜ë„ë¡ í•œë‹¤.
        utm_msg.data = [self.x, self.y]
        os.system('clear')
        print(' lat : ', ìœ„ë„ ë°ì´í„°)
        print(' lon : ', ê²½ë„ ë°ì´í„°)
        print(' utm X : ', utm ì¢Œí‘œë¡œ ë³€í™˜í•œ x ì¢Œí‘œ)
        print(' utm Y : ', utm ì¢Œí‘œë¡œ ë³€í™˜í•œ y ì¢Œí‘œ)

        '''

#TODO: (3) ìœ„ë„ ê²½ë„ ë°ì´í„°ë¥¼ UTM ì¢Œí‘œë¡œ ë³€í™˜
    def convertLL2UTM(self):
        '''
        # pyproj ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì´ìš©í•´ ì •ì˜í•œ ì¢Œí‘œ ë³€í™˜ ë³€ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ìœ„ ê²½ë„ ë°ì´í„°ë¥¼ ë³€í™˜í•œë‹¤.
        xy_zone = self.proj_UTM(ìœ„ë„ ë°ì´í„°, ê²½ë„ ë°ì´í„°)

        self.x = xy_zone[0]
        self.y = xy_zone[1]

        '''
```

<br>

#### 1-2) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import numpy as np
import tf
import os
from pyproj import Proj
from std_msgs.msg import Float32MultiArray
from morai_msgs.msg import GPSMessage, EgoVehicleStatus

# gps_parser ëŠ” GPSì˜ ìœ„ê²½ë„ ë°ì´í„°ë¥¼ UTM ì¢Œí‘œë¡œ ë³€í™˜í•˜ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.
# Pyproj ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš© 

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. ë³€í™˜ í•˜ê³ ì í•˜ëŠ” ì¢Œí‘œê³„ë¥¼ ì„ ì–¸  
# 2. ì‹œë®¬ë ˆì´í„°ì—ì„œ GPS ë°ì´í„°ë¥¼ ë°›ì•„ì˜¤ëŠ” Callback í•¨ìˆ˜ ìƒì„± 
# 3. ìœ„ë„ ê²½ë„ ë°ì´í„°ë¥¼ UTM ì¢Œí‘œë¡œ ë³€í™˜   
# 4. ìœ„ë„ ê²½ë„ ë°ì´í„°ì™€ ë³€í™˜í•œ UTM ì¢Œí‘œë¥¼ í„°ë¯¸ë„ ì°½ì— ì¶œë ¥ í•˜ì—¬ í™•ì¸  

class LL2UTMConverter:
    def __init__(self, zone=52) :
        self.gps_sub = rospy.Subscriber("/gps", GPSMessage, self.navsat_callback)
        # ì´ˆê¸°í™”
        self.x, self.y = None, None

        # (1) ë³€í™˜ í•˜ê³ ì í•˜ëŠ” ì¢Œí‘œê³„ë¥¼ ì„ ì–¸
        
        # GPS ì„¼ì„œì—ì„œ ìˆ˜ì‹ ë˜ëŠ” ìœ„ë„, ê²½ë„ ë°ì´í„°ë¥¼ UTM ì¢Œí‘œë£Œ ë³€í™˜ í•˜ê¸° ìœ„í•œ ì˜ˆì œì´ë‹¤.
        # í•´ë‹¹ ì˜ˆì œëŠ” WGS84 ì¢Œí‘œê³„ì—ì„œ UTM ì¢Œí‘œê³„ë¡œì˜ ë³€í™˜ì„ ì§„í–‰í•œë‹¤.
        # ì‹œë®¬ë ˆì´í„° K-City Map ì˜ ê²½ìš° UTM ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•˜ë©° ì‹¤ì œ ì§€ë„ ìƒ ìœ„ì¹˜ëŠ” UTM ì¢Œí‘œê³„ì˜ 52 Zone ì— ì¡´ì¬í•œë‹¤.
        # ë§µ ì¢Œí‘œê³„ëŠ” m ë‹¨ìœ„ë¥¼ ì‚¬ìš©í•œë‹¤.
        # ì•„ë˜ ì£¼ì†Œì˜ ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ Ptoj ì˜ ì‚¬ìš© ë°©ë²•ì„ í™•ì¸í•œë‹¤.
        # https://pyproj4.github.io/pyproj/stable/api/proj.html
        # " proj= , zone= , ellps =  , preserve_units = "
        self.proj_UTM = Proj(proj='utm', zone=zone, ellps='WGS84' )

        

    #(2) ì‹œë®¬ë ˆì´í„°ì—ì„œ GPS ë°ì´í„°ë¥¼ ë°›ì•„ì˜¤ëŠ” Callback í•¨ìˆ˜ ìƒì„±
    def navsat_callback(self, gps_msg):
        
        # GPS ì„¼ì„œì—ì„œ ìˆ˜ì‹ ë˜ëŠ” ìœ„ë„ ê²½ë„ ë°ì´í„°ë¥¼ í™•ì¸í•œë‹¤.
        self.lat = gps_msg.latitude
        self.lon = gps_msg.longitude

        
        self.convertLL2UTM()

        utm_msg = Float32MultiArray()

        #(4) ìœ„ë„ ê²½ë„ ë°ì´í„°ì™€ ë³€í™˜í•œ UTM ì¢Œí‘œë¥¼ í„°ë¯¸ë„ ì°½ì— ì¶œë ¥ í•˜ì—¬ í™•ì¸
        
        # UTM ìœ¼ë¡œ ë³€í™˜ ëœ ì¢Œí‘œ ë°ì´í„°ì™€ ìœ„ë„ ê²½ë„ ë°ì´í„°ë¥¼ í„°ë¯¸ë„ ì°½ì— ì¶œë ¥ë˜ë„ë¡ í•œë‹¤.
        utm_msg.data = [self.x, self.y]
        os.system('clear')
        print(' lat : ', self.lat)
        print(' lon : ', self.lon)
        print(' utm X : ', self.x)
        print(' utm Y : ', self.y)

    #(3) ìœ„ë„ ê²½ë„ ë°ì´í„°ë¥¼ UTM ì¢Œí‘œë¡œ ë³€í™˜
    def convertLL2UTM(self):
        # pyproj ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì´ìš©í•´ ì •ì˜í•œ ì¢Œí‘œ ë³€í™˜ ë³€ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ìœ„ ê²½ë„ ë°ì´í„°ë¥¼ ë³€í™˜í•œë‹¤.
        xy_zone = self.proj_UTM(self.lon, self.lat)

        self.x = xy_zone[0]
        self.y = xy_zone[1]

if __name__ == '__main__':

    rospy.init_node('gps_parser', anonymous=True)

    gps_parser = LL2UTMConverter()

    rospy.spin()
        

```

<br>



#### 1-3) ê²°ê³¼


![GPS_Parser](../images/ëª…ì„¸ì„œ(2)_images/gps_parser.png)

<br>

---

## 2. gpsimu_parser.py

<br>

#### ğŸ’¡ Odometry (ì£¼í–‰ê±°ë¦¬ ì¸¡ì •ê¸°)

- ì£¼í–‰ ë¡œë´‡ì´ë‚˜ ì°¨ëŸ‰ê³¼ ê°™ì€ ì´ë™ ë¡œë´‡ì˜ ìœ„ì¹˜ ë° ìì„¸ ì¶”ì •ì— ì‚¬ìš©ë˜ëŠ” ì¤‘ìš”í•œ ì„¼ì„œ ë°ì´í„°
- ë¡œë´‡ì˜ í˜„ì¬ ìœ„ì¹˜ì™€ ë°©í–¥ì„ ì¶”ì •í•˜ëŠ” ë° ì‚¬ìš©
- ë³´í†µ ìœ„ì¹˜ì™€ ìì„¸ë¥¼ 3D ì¢Œí‘œê³„ë¡œ ë‚˜íƒ€ë‚´ë©°, ì£¼ë¡œ ì°¨ëŸ‰ì˜ x, y ìœ„ì¹˜ ë° ì˜¤ì¼ëŸ¬ ê°ë„(roll, pitch, yaw)ë¡œ í‘œí˜„

<br>

**ğŸ’¡ ROSì—ì„œëŠ” **`nav_msgs/Odometry`** ë©”ì‹œì§€ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¡œë´‡ì˜ í˜„ì¬ ìœ„ì¹˜ì™€ ìì„¸ë¥¼ ë‚˜íƒ€ëƒ„**

1. ë¡œë´‡ì˜ ìœ„ì¹˜: x, y, z ì¢Œí‘œë¡œ í‘œí˜„
2. ë¡œë´‡ì˜ ìì„¸: ì¿¼í„°ë‹ˆì–¸(quaternion)ìœ¼ë¡œ í‘œí˜„
3. ìì„¸ ì¶”ì • ì‹œê°„: ë©”ì‹œì§€ê°€ ìƒì„±ëœ ì‹œê°„ì´ë‚˜ íŠ¹ì • ì‹œê°„ìœ¼ë¡œ ì„¤ì •
4. ì„ ì†ë„(Linear velocity) ë° ê°ì†ë„(Angular velocity): ë¡œë´‡ì˜ ì„ ì†ë„ ë° ê°ì†ë„ë¥¼ ë‚˜íƒ€ëƒ„


#### 2-1) To Do

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
 
import rospy
import tf
import os
from std_msgs.msg import Float32MultiArray
from sensor_msgs.msg import Imu
from morai_msgs.msg import GPSMessage
from nav_msgs.msg import Odometry
from pyproj import Proj
from math import pi

# gpsimu_parser ëŠ” GPS, IMU ì„¼ì„œ ë°ì´í„°ë¥¼ ë°›ì•„ ì°¨ëŸ‰ì˜ ìƒëŒ€ìœ„ì¹˜ë¥¼ ì¶”ì •í•˜ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. ë³€í™˜ í•˜ê³ ì í•˜ëŠ” ì¢Œí‘œê³„ë¥¼ ì„ ì–¸
# 2. ì†¡ì‹  ë  Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ ìƒì„±
# 3. ìœ„ë„ ê²½ë„ ë°ì´í„° UTM ì£„í‘œë¡œ ë³€í™˜
# 4. Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ì— ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ë° ìƒíƒœ ë°ì´í„° ë‹´ê¸°
# 5. Odometry ë©”ì„¸ì§€ Publish

class GPSIMUParser:
    def __init__(self):
        rospy.init_node('GPS_IMU_parser', anonymous=True)
        self.gps_sub = rospy.Subscriber("/gps", GPSMessage, self.navsat_callback)
        self.imu_sub = rospy.Subscriber("/imu", Imu, self.imu_callback)
        self.odom_pub = rospy.Publisher('/odom',Odometry, queue_size=1)
        # ì´ˆê¸°í™”
        self.x, self.y = None, None
        self.is_imu=False
        self.is_gps=False

        #TODO: (1) ë³€í™˜ í•˜ê³ ì í•˜ëŠ” ì¢Œí‘œê³„ë¥¼ ì„ ì–¸
        '''
        # GPS ì„¼ì„œì—ì„œ ìˆ˜ì‹ ë˜ëŠ” ìœ„ë„, ê²½ë„ ë°ì´í„°ë¥¼ UTM ì¢Œí‘œë£Œ ë³€í™˜ í•˜ê¸° ìœ„í•œ ì˜ˆì œì´ë‹¤.
        # í•´ë‹¹ ì˜ˆì œëŠ” WGS84 ì¢Œí‘œê³„ì—ì„œ UTM ì¢Œí‘œê³„ë¡œì˜ ë³€í™˜ì„ ì§„í–‰í•œë‹¤.
        # ì‹œë®¬ë ˆì´í„° K-City Map ì˜ ê²½ìš° UTM ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•˜ë©° ì‹¤ì œ ì§€ë„ ìƒ ìœ„ì¹˜ëŠ” UTM ì¢Œí‘œê³„ì˜ 52 Zone ì— ì¡´ì œí•œë‹¤.
        # ë§µ ì¢Œí‘œê³„ëŠ” m ë‹¨ìœ„ë¥¼ ì‚¬ìš©í•œë‹¤.
        # ì•„ë˜ ì£¼ì†Œì˜ ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ Ptoj ì˜ ì‚¬ìš© ë°©ë²•ì„ í™•ì¸í•œë‹¤.
        # https://pyproj4.github.io/pyproj/stable/api/proj.html
        # " proj= , zone= , ellps =  , preserve_units = "
        self.proj_UTM = Proj( ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ë³€ìˆ˜ ì…ë ¥ )

        '''

        #TODO: (2) ì†¡ì‹  ë  Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ ìƒì„±
        '''
        # ROS ë©”ì„¸ì§€ ì¤‘ ë¬¼ì²´ì˜ ìœ„ì¹˜ì™€ ìì„¸ ë°ì´í„°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” Odometry ë©”ì„¸ì§€ë¥¼ ì‚¬ìš©í•œë‹¤.
        # ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ì™€ ìì„¸ ë°ì´í„°ë¥¼ GPS IMU ì„¼ì„œì— ë‹´ì•„ì„œ Publsih í•œë‹¤.
        # ì´ë•Œ frame_id ëŠ” '/odom' child_frame_id ëŠ” '/base_link' ë¡œ í•œë‹¤.

        self.odom_msg = 
        self.odom_msg.header.frame_id = 
        self.odom_msg.child_frame_id = 

        '''

        rate = rospy.Rate(30) # 30hz
        while not rospy.is_shutdown():
            if self.is_imu==True and self.is_gps == True:
                self.convertLL2UTM()

                #TODO: (5) Odometry ë©”ì„¸ì§€ Publish
                '''
                # Odometry ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.odom_pub.
                
                '''

                os.system('clear')
                print(" ROS Odometry Msgs Pose ")
                print(self.odom_msg.pose.pose.position)
                print(" ROS Odometry Msgs Orientation ")
                print(self.odom_msg.pose.pose.orientation)

                rate.sleep()

    def navsat_callback(self, gps_msg):

        self.lat = gps_msg.latitude
        self.lon = gps_msg.longitude
        self.e_o = gps_msg.eastOffset
        self.n_o = gps_msg.northOffset

        self.is_gps=True

    #TODO: (3) ìœ„ë„ ê²½ë„ ë°ì´í„° UTM ì£„í‘œë¡œ ë³€í™˜
    def convertLL2UTM(self):
        '''
        # pyproj ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì´ìš©í•´ ì •ì˜í•œ ì¢Œí‘œ ë³€í™˜ ë³€ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ìœ„ ê²½ë„ ë°ì´í„°ë¥¼ ë³€í™˜í•œë‹¤.
        # ë³€í™˜ ì‹œ ì´ì „ gps_parser.py ì˜ˆì œì™€ ë‹¬ë¦¬ ì‹œë®¬ë ˆì´í„° GPS ì„¼ì„œì˜ offset ê°’ì„ ì ìš© í•œë‹¤.
        # GPS ì„¼ì„œì—ì„œ ì¶œë ¥ë˜ëŠ” Offset ê°’ì€ ì‹œë®¬ë ˆì´í„°ì— ë§µ ì¢Œí‘œê³„ë¡œ ë³€ê²½ì„ ìœ„í•œ ê°’ì´ë‹¤.
        # UTM ì¢Œí‘œë¡œ ë³€í™˜ ëœ x, y ê°’ì— offset ê°’ì„ ë¹¼ì£¼ë©´ ëœë‹¤.
        xy_zone = self.proj_UTM(ìœ„ë„ ë°ì´í„°, ê²½ë„ ë°ì´í„°)

        # if ë¬¸ì„ ì´ìš© ì˜ˆì™¸ì²˜ë¦¬ë¥¼ í•˜ëŠ” ì´ìœ ëŠ” ì‹œë®¬ë ˆì´í„° ìŒì˜ êµ¬ê°„ ì„¤ì • ì„¼ì„œ ë°ì´í„°ê°€ 0.0 ìœ¼ë¡œ ë‚˜ì˜¤ê¸° ë•Œë¬¸ì´ë‹¤.
        if self.lon == 0 and self.lat == 0:
            self.x = 0.0
            self.y = 0.0
        else:
            self.x = xy_zone[0] - self.e_o
            self.y = xy_zone[1] - self.n_o

        '''

        #TODO: (4) Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ì— ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ë° ìƒíƒœ ë°ì´í„° ë‹´ê¸°
        '''
        # Offset ì„ ì ìš©í•˜ì—¬ ì‹œë®¬ë ˆì´í„° ë§µ ì¢Œí‘œê³„ ê°’ìœ¼ë¡œ ë³€í™˜ ëœ ì¢Œí‘œ ë°ì´í„°ë¥¼ Odometry ë©”ì„¸ì§€ì— ë„£ëŠ”ë‹¤.
        self.odom_msg.header.stamp = rospy.get_rostime()
        self.odom_msg.pose.pose.position.x = 
        self.odom_msg.pose.pose.position.y = 
        self.odom_msg.pose.pose.position.z =

        '''

    def imu_callback(self, data):

        #TODO: (4) Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ì— ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ë° ìƒíƒœ ë°ì´í„° ë‹´ê¸°
        '''
        # IMU ë¥¼ í†µí•´ ë°›ì€ ë¬¼ì²´ì˜ ìì„¸ ë°ì´í„°ë¥¼ Odometry ë©”ì„¸ì§€ì— ë„£ëŠ”ë‹¤.
        # if ë¬¸ì„ ì´ìš© ì˜ˆì™¸ì²˜ë¦¬ë¥¼ í•˜ëŠ” ì´ìœ ëŠ” ì‹œë®¬ë ˆì´í„° ìŒì˜ êµ¬ê°„ ì„¤ì • ì„¼ì„œ ë°ì´í„°ê°€ 0.0 ìœ¼ë¡œ ë‚˜ì˜¤ê¸° ë•Œë¬¸ì´ë‹¤.
        if data.orientation.w == 0:
            self.odom_msg.pose.pose.orientation.x = 0.0
            self.odom_msg.pose.pose.orientation.y = 0.0
            self.odom_msg.pose.pose.orientation.z = 0.0
            self.odom_msg.pose.pose.orientation.w = 1.0
        else:
            self.odom_msg.pose.pose.orientation.x = data.orientation.x
            self.odom_msg.pose.pose.orientation.y = data.orientation.y
            self.odom_msg.pose.pose.orientation.z = data.orientation.z
            self.odom_msg.pose.pose.orientation.w = data.orientation.w

        '''
        self.is_imu=True

if __name__ == '__main__':
    try:
        GPS_IMU_parser = GPSIMUParser()
    except rospy.ROSInterruptException:
        pass

```
<br>

#### 2-2) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
 
import rospy
import tf
import os
from std_msgs.msg import Float32MultiArray
from sensor_msgs.msg import Imu
from morai_msgs.msg import GPSMessage
from nav_msgs.msg import Odometry
from pyproj import Proj
from math import pi

# gpsimu_parser ëŠ” GPS, IMU ì„¼ì„œ ë°ì´í„°ë¥¼ ë°›ì•„ ì°¨ëŸ‰ì˜ ìƒëŒ€ìœ„ì¹˜ë¥¼ ì¶”ì •í•˜ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. ë³€í™˜ í•˜ê³ ì í•˜ëŠ” ì¢Œí‘œê³„ë¥¼ ì„ ì–¸
# 2. ì†¡ì‹  ë  Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ ìƒì„±
# 3. ìœ„ë„ ê²½ë„ ë°ì´í„° UTM ì£„í‘œë¡œ ë³€í™˜
# 4. Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ì— ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ë° ìƒíƒœ ë°ì´í„° ë‹´ê¸°
# 5. Odometry ë©”ì„¸ì§€ Publish

class GPSIMUParser:
    def __init__(self):
        rospy.init_node('GPS_IMU_parser', anonymous=True)
        self.gps_sub = rospy.Subscriber("/gps", GPSMessage, self.navsat_callback)
        self.imu_sub = rospy.Subscriber("/imu", Imu, self.imu_callback)
        self.odom_pub = rospy.Publisher('/odom',Odometry, queue_size=1)
        # ì´ˆê¸°í™”
        self.x, self.y = None, None
        self.is_imu=False
        self.is_gps=False

        #(1) ë³€í™˜ í•˜ê³ ì í•˜ëŠ” ì¢Œí‘œê³„ë¥¼ ì„ ì–¸
        
        # GPS ì„¼ì„œì—ì„œ ìˆ˜ì‹ ë˜ëŠ” ìœ„ë„, ê²½ë„ ë°ì´í„°ë¥¼ UTM ì¢Œí‘œë£Œ ë³€í™˜ í•˜ê¸° ìœ„í•œ ì˜ˆì œì´ë‹¤.
        # í•´ë‹¹ ì˜ˆì œëŠ” WGS84 ì¢Œí‘œê³„ì—ì„œ UTM ì¢Œí‘œê³„ë¡œì˜ ë³€í™˜ì„ ì§„í–‰í•œë‹¤.
        # ì‹œë®¬ë ˆì´í„° K-City Map ì˜ ê²½ìš° UTM ì¢Œí‘œê³„ë¥¼ ì‚¬ìš©í•˜ë©° ì‹¤ì œ ì§€ë„ ìƒ ìœ„ì¹˜ëŠ” UTM ì¢Œí‘œê³„ì˜ 52 Zone ì— ì¡´ì œí•œë‹¤.
        # ë§µ ì¢Œí‘œê³„ëŠ” m ë‹¨ìœ„ë¥¼ ì‚¬ìš©í•œë‹¤.
        # ì•„ë˜ ì£¼ì†Œì˜ ë§í¬ë¥¼ í´ë¦­í•˜ì—¬ Ptoj ì˜ ì‚¬ìš© ë°©ë²•ì„ í™•ì¸í•œë‹¤.
        # https://pyproj4.github.io/pyproj/stable/api/proj.html
        # " proj= , zone= , ellps =  , preserve_units = "
        self.proj_UTM = Proj( proj='utm', zone=52, ellps='WGS84' )

        

        #(2) ì†¡ì‹  ë  Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ ìƒì„±
        
        # ROS ë©”ì„¸ì§€ ì¤‘ ë¬¼ì²´ì˜ ìœ„ì¹˜ì™€ ìì„¸ ë°ì´í„°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” Odometry ë©”ì„¸ì§€ë¥¼ ì‚¬ìš©í•œë‹¤.
        # ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ì™€ ìì„¸ ë°ì´í„°ë¥¼ GPS IMU ì„¼ì„œì— ë‹´ì•„ì„œ Publsih í•œë‹¤.
        # ì´ë•Œ frame_id ëŠ” '/odom' child_frame_id ëŠ” '/base_link' ë¡œ í•œë‹¤.

        self.odom_msg = Odometry()
        self.odom_msg.header.frame_id = '/odom'
        self.odom_msg.child_frame_id =  '/base_link'

        

        rate = rospy.Rate(30) # 30hz
        while not rospy.is_shutdown():
            if self.is_imu==True and self.is_gps == True:
                self.convertLL2UTM()

                #(5) Odometry ë©”ì„¸ì§€ Publish
                
                # Odometry ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.odom_pub.publish(self.odom_msg)
                
                

                os.system('clear')
                print(" ROS Odometry Msgs Pose ")
                print(self.odom_msg.pose.pose.position)
                print(" ROS Odometry Msgs Orientation ")
                print(self.odom_msg.pose.pose.orientation)

                rate.sleep()

    def navsat_callback(self, gps_msg):

        self.lat = gps_msg.latitude
        self.lon = gps_msg.longitude
        self.e_o = gps_msg.eastOffset
        self.n_o = gps_msg.northOffset

        self.is_gps=True

    #(3) ìœ„ë„ ê²½ë„ ë°ì´í„° UTM ì£„í‘œë¡œ ë³€í™˜
    def convertLL2UTM(self):
        
        # pyproj ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì´ìš©í•´ ì •ì˜í•œ ì¢Œí‘œ ë³€í™˜ ë³€ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ìœ„ ê²½ë„ ë°ì´í„°ë¥¼ ë³€í™˜í•œë‹¤.
        # ë³€í™˜ ì‹œ ì´ì „ gps_parser.py ì˜ˆì œì™€ ë‹¬ë¦¬ ì‹œë®¬ë ˆì´í„° GPS ì„¼ì„œì˜ offset ê°’ì„ ì ìš© í•œë‹¤.
        # GPS ì„¼ì„œì—ì„œ ì¶œë ¥ë˜ëŠ” Offset ê°’ì€ ì‹œë®¬ë ˆì´í„°ì— ë§µ ì¢Œí‘œê³„ë¡œ ë³€ê²½ì„ ìœ„í•œ ê°’ì´ë‹¤.
        # UTM ì¢Œí‘œë¡œ ë³€í™˜ ëœ x, y ê°’ì— offset ê°’ì„ ë¹¼ì£¼ë©´ ëœë‹¤.
        xy_zone = self.proj_UTM(self.lon, self.lat)

        # if ë¬¸ì„ ì´ìš© ì˜ˆì™¸ì²˜ë¦¬ë¥¼ í•˜ëŠ” ì´ìœ ëŠ” ì‹œë®¬ë ˆì´í„° ìŒì˜ êµ¬ê°„ ì„¤ì • ì„¼ì„œ ë°ì´í„°ê°€ 0.0 ìœ¼ë¡œ ë‚˜ì˜¤ê¸° ë•Œë¬¸ì´ë‹¤.
        if self.lon == 0 and self.lat == 0:
            self.x = 0.0
            self.y = 0.0
        else:
            self.x = xy_zone[0] - self.e_o
            self.y = xy_zone[1] - self.n_o

        

        #TODO: (4) Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ì— ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ë° ìƒíƒœ ë°ì´í„° ë‹´ê¸°
        
        # Offset ì„ ì ìš©í•˜ì—¬ ì‹œë®¬ë ˆì´í„° ë§µ ì¢Œí‘œê³„ ê°’ìœ¼ë¡œ ë³€í™˜ ëœ ì¢Œí‘œ ë°ì´í„°ë¥¼ Odometry ë©”ì„¸ì§€ì— ë„£ëŠ”ë‹¤.
        self.odom_msg.header.stamp = rospy.get_rostime()
        self.odom_msg.pose.pose.position.x = self.x
        self.odom_msg.pose.pose.position.y = self.y
        self.odom_msg.pose.pose.position.z = 0.0

        

    def imu_callback(self, data):

        #(4) Odometry ë©”ì„¸ì§€ ë³€ìˆ˜ì— ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ë° ìƒíƒœ ë°ì´í„° ë‹´ê¸°
        
        # IMU ë¥¼ í†µí•´ ë°›ì€ ë¬¼ì²´ì˜ ìì„¸ ë°ì´í„°ë¥¼ Odometry ë©”ì„¸ì§€ì— ë„£ëŠ”ë‹¤.
        # if ë¬¸ì„ ì´ìš© ì˜ˆì™¸ì²˜ë¦¬ë¥¼ í•˜ëŠ” ì´ìœ ëŠ” ì‹œë®¬ë ˆì´í„° ìŒì˜ êµ¬ê°„ ì„¤ì • ì„¼ì„œ ë°ì´í„°ê°€ 0.0 ìœ¼ë¡œ ë‚˜ì˜¤ê¸° ë•Œë¬¸ì´ë‹¤.
        if data.orientation.w == 0:
            self.odom_msg.pose.pose.orientation.x = 0.0
            self.odom_msg.pose.pose.orientation.y = 0.0
            self.odom_msg.pose.pose.orientation.z = 0.0
            self.odom_msg.pose.pose.orientation.w = 1.0
        else:
            self.odom_msg.pose.pose.orientation.x = data.orientation.x
            self.odom_msg.pose.pose.orientation.y = data.orientation.y
            self.odom_msg.pose.pose.orientation.z = data.orientation.z
            self.odom_msg.pose.pose.orientation.w = data.orientation.w

        
        self.is_imu=True

if __name__ == '__main__':
    try:
        GPS_IMU_parser = GPSIMUParser()
    except rospy.ROSInterruptException:
        pass

```
<br>

#### 2-3) ê²°ê³¼

![GPS-IMU_Parser](../images/ëª…ì„¸ì„œ(2)_images/gps_imu_parser.png
)


##### ğŸ’¡ ë°ì´í„°

1. ë¡œë´‡ì˜ ìœ„ì¹˜(Pose): x, y, z ì¢Œí‘œë¡œ í‘œí˜„
2. ë¡œë´‡ì˜ ìì„¸(Orientation): ì¿¼í„°ë‹ˆì–¸(quaternion)
    - **x, y, z** : xì¶•, yì¶•, zì¶•ì„ ë”°ë¼ íšŒì „í•˜ëŠ” ì–‘
    - **w** : íšŒì „ì˜ í¬ê¸° ë˜ëŠ” ê°•ë„ (ìŠ¤ì¹¼ë¼)


<br>

---



## 3. tf_pub.py


#### ğŸ’¡ ë¬¼ì²´ì˜ ìœ„ì¹˜ì™€ ìì„¸ ë°ì´í„°ë¥¼ ì¢Œí‘œê³„ë¡œ ë‚˜íƒ€ë‚´ëŠ” ì˜ˆì œ

- gpsimu_parser.pyë¥¼ ì‹¤í–‰ì‹œì¼œì•¼í•¨
- gpsimu_parser.pyë¡œë¶€í„° ë°ì´í„° ë°›ì•„ì„œ TF ë³€í™˜í•œ í›„ ë¸Œë¡œë“œìºìŠ¤íŠ¸í•¨


#### ğŸ’¡ TF(Transform)

- ë¡œë´‡ì˜ ìœ„ì¹˜ì™€ ìì„¸ë¥¼ ê´€ë¦¬í•˜ê³  ë‹¤ë£¨ëŠ” ROSì˜ ë¼ì´ë¸ŒëŸ¬ë¦¬
- TFëŠ” ë¡œë´‡ì˜ ë‹¤ì–‘í•œ ì„¼ì„œ ë° êµ¬ì„± ìš”ì†Œë¡œë¶€í„° ìˆ˜ì‹ ëœ ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¡œë´‡ì˜ ì „ì—­ ì¢Œí‘œê³„(global coordinate frame)ì—ì„œ ë¡œì»¬ ì¢Œí‘œê³„(local coordinate frame)ë¡œì˜ ë³€í™˜ì„ ìˆ˜í–‰
- ë¡œë´‡ ì‹œìŠ¤í…œ ë‚´ì—ì„œ ë‹¤ì–‘í•œ ì„¼ì„œ ë° ë¶€í’ˆ ê°„ì˜ ìƒëŒ€ì ì¸ ìœ„ì¹˜ ë° ìì„¸ë¥¼ ì¶”ì í•˜ê³  ê´€ë¦¬
- ë¡œë´‡ ì‹œìŠ¤í…œì˜ ë‹¤ì–‘í•œ ë¶€ë¶„ ê°„ì˜ ë³€í™˜ ê´€ê³„ë¥¼ ìœ ì§€í•˜ê³  ì—…ë°ì´íŠ¸í•  ìˆ˜ ìˆëŠ” ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µ (ì´ëŸ¬í•œ ë³€í™˜ ê´€ê³„ëŠ” ë¡œë´‡ ì‹œìŠ¤í…œì—ì„œ ì‚¬ìš©ë˜ëŠ” ì—¬ëŸ¬ í”„ë ˆì„(frame) ê°„ì˜ ìƒëŒ€ì ì¸ ìœ„ì¹˜ ë° ìì„¸ë¥¼ ì„¤ëª…)
- ì‹œê°„ì´ ì§€ë‚¨ì— ë”°ë¼ ì´ëŸ¬í•œ ë³€í™˜ ê´€ê³„ë¥¼ ì—…ë°ì´íŠ¸í•˜ë©°, ë‹¤ë¥¸ ë…¸ë“œì—ì„œ TF ì •ë³´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¡œë´‡ì˜ ìƒëŒ€ì ì¸ ìœ„ì¹˜ ë° ìì„¸ë¥¼ ì¶”ì í•˜ê³  ì œì–´í•˜ëŠ” ë° í™œìš©

#### ğŸ’¡ TFì˜ í•µì‹¬ ê¸°ëŠ¥

1. ë¡œë´‡ì˜ ë‹¤ì–‘í•œ ë¶€ë¶„ ê°„ì˜ ìƒëŒ€ì ì¸ ìœ„ì¹˜ ë° ìì„¸ë¥¼ ì¶”ì í•˜ê³  ìœ ì§€
2. ë¡œë´‡ ì‹œìŠ¤í…œ ë‚´ì—ì„œ ë‹¤ì–‘í•œ í”„ë ˆì„ ê°„ì˜ ë³€í™˜ ê´€ê³„ë¥¼ ì—…ë°ì´íŠ¸ ë° ìœ ì§€
3. ë‹¤ì–‘í•œ ì„¼ì„œ ë° ë¶€í’ˆ ê°„ì˜ ìƒëŒ€ì ì¸ ìœ„ì¹˜ ë° ìì„¸ ì •ë³´ ì œê³µ
4. ROS ì‹œìŠ¤í…œì—ì„œ ë¡œë´‡ì˜ ìœ„ì¹˜ ë° ìì„¸ ì •ë³´ë¥¼ ê³µìœ í•˜ê³  ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” í‘œì¤€í™”ëœ ë©”ì»¤ë‹ˆì¦˜ì„ ì œê³µ


#### ğŸ’¡ ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
import rospy
import tf
from math import pi
from nav_msgs.msg import Odometry

# tf ëŠ” ë¬¼ì²´ì˜ ìœ„ì¹˜ì™€ ìì„¸ ë°ì´í„°ë¥¼ ì¢Œí‘œê³„ë¡œ ë‚˜íƒ€ë‚´ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. Callback í•¨ìˆ˜ ìƒì„±
# 2. ë¸Œë¡œë“œìºìŠ¤í„° ìƒì„± ë° Ego ìƒíƒœ tf ë¸Œë¡œë“œìºìŠ¤íŒ…

class Ego_listener():
    def __init__(self):
        rospy.init_node('status_listener', anonymous=True)
        
        rospy.Subscriber("odom", Odometry, self.odom_callback)
        rospy.spin()

    #(1) Callback í•¨ìˆ˜ ìƒì„±
    def odom_callback(self,msg):
        self.is_odom = True

 
        # gpsimu_parser.py ì˜ˆì œì—ì„œ Publish í•´ì£¼ëŠ” Odometry ë©”ì„¸ì§€ ë°ì´í„°ë¥¼ Subscribe í•œë‹¤.
        # Odometry ë©”ì„¸ì§€ ì— ë‹´ê¸´ ë¬¼ì²´ì˜ ìœ„ì¹˜ ì™€ ìì„¸ ë°ì´í„°ë¥¼ ì•„ë˜ ë³€ìˆ˜ì— ë„£ì–´ì¤€ë‹¤.
        self.x = msg.pose.pose.position.x 
        self.y = msg.pose.pose.position.y

        self.orientation_x = msg.pose.pose.orientation.x
        self.orientation_y = msg.pose.pose.orientation.y
        self.orientation_z = msg.pose.pose.orientation.z
        self.orientation_w = msg.pose.pose.orientation.w

        
        
        #(2) ë¸Œë¡œë“œìºìŠ¤í„° ìƒì„± ë° Ego ìƒíƒœ tf ë¸Œë¡œë“œìºìŠ¤íŒ…
        
        # TF ë°ì´í„°ë¥¼ broadcast í•´ì£¼ëŠ” ë³€ìˆ˜ë¥¼ ì„ ì–¸í•œë‹¤.
        # TF ë°ì´í„°ì— ë¬¼ì²´ì˜ ì¢Œí‘œì™€ ìì„¸ ë°ì´í„°ë¥¼ ì‹œê°„ ê·¸ë¦¬ê³  Frame ID ë¥¼ ë„£ì–´ì£¼ë©´ ëœë‹¤.
        # TF ì˜ˆì œëŠ” map ì¢Œí‘œ ë¥¼ ê¸°ì¤€ìœ¼ë¡œ Ego ì°¨ëŸ‰ì˜ ìœ„ì¹˜ë¥¼ ì¢Œí‘œë¥¼ ë‚˜íƒ€ë‚¸ë‹¤
        br = tf.TransformBroadcaster()

        print("Hi")
        br.sendTransform((self.x, self.y, 0),
                        (self.orientation_x,self.orientation_y,self.orientation_z,self.orientation_w),
                        rospy.Time.now(),
                        "Ego",
                        "map")

        

if __name__ == '__main__':
    try:
        tl=Ego_listener()
    except rospy.ROSInternalException:
        pass

```

<br>

---

## 4. mgeo & mgeo_pub


#### ğŸ’¡ VS Codeì—ì„œ ê¸°ì¡´ Python Debugger ì œê±° í›„ Debugpy Old ì„¤ì¹˜

- Python ë²„ì „ì´ ë‚®ì•„ì„œ ì˜ˆì „ Debug ë²„ì „ ì‚¬ìš©í•´ì•¼í•¨
- Debugging í•˜ì—¬ mgeo ë°ì´í„° ë³´ê¸°

![VScode Debugger](../images/ëª…ì„¸ì„œ(2)_images/vscode_debugger.png)

<br>

#### 4-1) mgeo ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys

current_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(current_path)

from lib.mgeo.class_defs import *

# mgeo ëŠ” ì •ë°€ë„ë¡œì§€ë„ ë°ì´í„° ì¸ MGeo(MORAI Geometry) ë°ì´í„°ë¥¼ ì½ì–´ì˜¤ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.
# Json íŒŒì¼ í˜•ì‹ìœ¼ë¡œ ë˜ì–´ ìˆëŠ” MGeo ë°ì´í„°ë¥¼ dictionary í˜•íƒœë¡œ ì½ì–´ì˜µë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸

#(1) Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸

# Json íŒŒì¼ í˜•ì‹ìœ¼ë¡œ ì €ì¥ëœ MGeo ë°ì´í„°ë¥¼ ì½ì–´ì˜¤ëŠ” ì˜ˆì œ ì…ë‹ˆë‹¤.
# VScode ì˜ debug ê¸°ëŠ¥ì„ ì´ìš©í•˜ì—¬ MGeo ë°ì´í„°ë¥¼ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
# MGeo ë°ì´í„°ëŠ” ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë°©ì‹ì˜ ê·¸ë˜í”„ êµ¬ì¡° ì…ë‹ˆë‹¤.
# ì •ë°€ë„ë¡œì§€ë„ì˜ ë„ë¡œ ê°„ì˜ ì—°ê²° ê´€ê³„ë¥¼ í‘œí˜„ í•©ë‹ˆë‹¤.
# MGeo ì—ëŠ” ë„ë¡œì˜ í˜•ìƒì„ ë‚˜íƒ€ë‚´ëŠ” Node ì™€ Link ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤.
# Node ì™€ Link ëŠ” ëª¨ë‘ Point ë°ì´í„° ë“¤ì˜ ì§‘í•©ì…ë‹ˆë‹¤.
# Node ëŠ” ì„œë¡œ ë‹¤ë¥¸ ë‘ê°œ ì´ìƒì˜ Link ê°„ì˜ ì—°ê²° ì—¬ë¶€ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
# Link ëŠ” ë„ë¡œë¥¼ í‘œí˜„í•˜ë©° ë„ë¡œ ì˜ ì¤‘ì‹¬ ì„ ì´ ë©ë‹ˆë‹¤.
# Link ì™€ Node ì •ë³´ê°€ ëª¨ì—¬ ë„ë¡œì˜ í˜•ìƒì„ í‘œí˜„í•©ë‹ˆë‹¤.
# ê°ê°ì˜ Node Link ì •ë³´ëŠ” ì´ë¦„ì¸ idx ì •ë³´ë¥¼ ê°€ì§‘ë‹ˆë‹¤ idx ëŠ” ì¤‘ë³µ ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. 
# to_links , from_links , to_node , from_node ... ë“± 
# MGeoì— ì •ì˜ë˜ì–´ ìˆëŠ” ë°ì´í„°ë¥¼ í™œìš©í•´ ê° Node ì™€ Link ê°„ ì—°ê²° ì„±ì„ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
# 

load_path = os.path.normpath(os.path.join(current_path, 'lib/mgeo_data/R_KR_PG_K-City'))
mgeo_planner_map = MGeo.create_instance_from_json(load_path)

# ì˜¬ë°”ë¥¸ MGeo ê°ì²´ ìƒì„± ë° JSON íŒŒì¼ë¡œë¶€í„° ë°ì´í„° ì½ê¸°
try:
    mgeo_planner_map = MGeo.create_instance_from_json(load_path)
except FileNotFoundError:
    print("JSON íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
    sys.exit(1)
except Exception as e:
    print("MGeo ë°ì´í„°ë¥¼ ì½ëŠ” ë™ì•ˆ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:", str(e))
    sys.exit(1)

node_set = mgeo_planner_map.node_set
link_set = mgeo_planner_map.link_set
nodes=node_set.nodes
links=link_set.lines

print('# of nodes: ', len(node_set.nodes))
print('# of links: ', len(link_set.lines))
```
<br>

#### 4-2) mgeo_pub ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import sys
import rospy

from nav_msgs.msg import Path
from geometry_msgs.msg import PoseStamped,Point32
from sensor_msgs.msg import PointCloud

current_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(current_path)

from lib.mgeo.class_defs import *

# mgeo_pub ì€ Mgeo ë°ì´í„°ë¥¼ ì½ì–´ì˜¨ ë’¤ ë„ë¡œ ì •ë³´ë¥¼ Point Cloud Data ë¡œ ë³€í™˜í•˜ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.
# Point Cloud í˜•ì‹ìœ¼ë¡œ ë³€í™˜ í›„ Rviz ë¥¼ ì´ìš©í•´ ì •ë°€ë„ë¡œì§€ë„ ë°ì´í„°ë¥¼ ì‹œê°í™” í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸
# 2. Link ì •ë³´ Point Cloud ë°ì´í„°ë¡œ ë³€í™˜
# 3. Node ì •ë³´ Point Cloud ë°ì´í„°ë¡œ ë³€í™˜
# 4. ë³€í™˜í•œ Link, Node ì •ë³´ Publish

class get_mgeo :
    def __init__(self):
        rospy.init_node('test', anonymous=True)
        self.link_pub = rospy.Publisher('link',PointCloud, queue_size=1)
        self.node_pub = rospy.Publisher('node',PointCloud, queue_size=1)

        #(1) Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸
        
        # Json íŒŒì¼ í˜•ì‹ìœ¼ë¡œ ì €ì¥ëœ MGeo ë°ì´í„°ë¥¼ ì½ì–´ì˜¤ëŠ” ì˜ˆì œ ì…ë‹ˆë‹¤.
        # VScode ì˜ debug ê¸°ëŠ¥ì„ ì´ìš©í•˜ì—¬ MGeo ë°ì´í„°ë¥¼ í™•ì¸ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        # MGeo ë°ì´í„°ëŠ” ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë°©ì‹ì˜ ê·¸ë˜í”„ êµ¬ì¡° ì…ë‹ˆë‹¤.
        # ì •ë°€ë„ë¡œì§€ë„ì˜ ë„ë¡œ ê°„ì˜ ì—°ê²° ê´€ê³„ë¥¼ í‘œí˜„ í•©ë‹ˆë‹¤.
        # MGeo ì—ëŠ” ë„ë¡œì˜ í˜•ìƒì„ ë‚˜íƒ€ë‚´ëŠ” Node ì™€ Link ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤.
        # Node ì™€ Link ëŠ” ëª¨ë‘ Point ë°ì´í„° ë“¤ì˜ ì§‘í•©ì…ë‹ˆë‹¤.
        # Node ëŠ” ì„œë¡œ ë‹¤ë¥¸ ë‘ê°œ ì´ìƒì˜ Link ê°„ì˜ ì—°ê²° ì—¬ë¶€ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
        # Link ëŠ” ë„ë¡œë¥¼ í‘œí˜„í•˜ë©° ë„ë¡œ ì˜ ì¤‘ì‹¬ ì„ ì´ ë©ë‹ˆë‹¤.
        # Link ì™€ Node ì •ë³´ê°€ ëª¨ì—¬ ë„ë¡œì˜ í˜•ìƒì„ í‘œí˜„í•©ë‹ˆë‹¤.
        # ê°ê°ì˜ Node Link ì •ë³´ëŠ” ì´ë¦„ì¸ idx ì •ë³´ë¥¼ ê°€ì§‘ë‹ˆë‹¤ idx ëŠ” ì¤‘ë³µ ë  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. 
        # to_links , from_links , to_node , from_node ... ë“± 
        # MGeoì— ì •ì˜ë˜ì–´ ìˆëŠ” ë°ì´í„°ë¥¼ í™œìš©í•´ ê° Node ì™€ Link ê°„ ì—°ê²° ì„±ì„ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        
        
        load_path = os.path.normpath(os.path.join(current_path, 'lib/mgeo_data/R_KR_PG_K-City'))
        mgeo_planner_map = MGeo.create_instance_from_json(load_path)

        node_set = mgeo_planner_map.node_set
        link_set = mgeo_planner_map.link_set

        self.nodes=node_set.nodes
        self.links=link_set.lines

        self.link_msg=self.getAllLinks()
        self.node_msg=self.getAllNode()

        print('# of nodes: ', len(node_set.nodes))
        print('# of links: ', len(link_set.lines))

        rate = rospy.Rate(1) 
        while not rospy.is_shutdown():

            #(4) ë³€í™˜í•œ Link, Node ì •ë³´ Publish
            
            # ë³€í™˜í•œ Link, Node ì •ë³´ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
            self.link_pub.publish(self.link_msg)
            self.node_pub.publish(self.node_msg)
            
            
                
            rate.sleep()

    def getAllLinks(self):
        all_link=PointCloud()
        all_link.header.frame_id='map'

        #(2) Link ì •ë³´ Point Cloud ë°ì´í„°ë¡œ ë³€í™˜
        
        # Point Cloud í˜•ì‹ìœ¼ë¡œ Link ì˜ ì¢Œí‘œ ì •ë³´ë¥¼ ë³€í™˜í•©ë‹ˆë‹¤.
        # Link ì˜ ê°œìˆ˜ ë§Œí¼ ë°˜ë³µí•˜ëŠ” ë°˜ë³µ ë¬¸ì„ ì´ìš©í•´ Link ì •ë³´ë¥¼ Point Cloud í˜•ì‹ ë°ì´í„°ì— ë„£ìŠµë‹ˆë‹¤.
        for link in self.links.values() : 
            for point in link.points:
                pt= Point32()
                pt.x = point[0]
                pt.y = point[1]
                pt.z = point[2]
                all_link.points.append(pt)

        return all_link
    
    def getAllNode(self):
        all_node=PointCloud()
        all_node.header.frame_id='map'

        #(3) Node ì •ë³´ Point Cloud ë°ì´í„°ë¡œ ë³€í™˜
        
        # Point Cloud í˜•ì‹ìœ¼ë¡œ Node ì˜ ì¢Œí‘œ ì •ë³´ë¥¼ ë³€í™˜í•©ë‹ˆë‹¤.
        # Node ì˜ ê°œìˆ˜ ë§Œí¼ ë°˜ë³µí•˜ëŠ” ë°˜ë³µ ë¬¸ì„ ì´ìš©í•´ Node ì •ë³´ë¥¼ Point Cloud í˜•ì‹ ë°ì´í„°ì— ë„£ìŠµë‹ˆë‹¤.

        for node in self.nodes.values() :
            pt = Point32()
            pt.x = node.point[0]
            pt.y = node.point[1]
            pt.z = node.point[2]
            all_node.points.append(pt)  

        return all_node

if __name__ == '__main__':
    
    test_track=get_mgeo()

```

<br>

#### 4-3) ì‹œê°í™”

```python
# rqt ì‹¤í–‰ í›„ tf, node, link ì„ íƒ
$ rqt

# rviz ì‹¤í–‰
$ rviz

# ì¢Œì¸¡í•˜ë‹¨ add ë²„íŠ¼ í´ë¦­ í›„ nodeì™€ link ì¶”ê°€
# ë§µì´ ê°„ì„ ê³¼ ì •ì ìœ¼ë¡œ ë‚˜íƒ€ë‚˜ëŠ” ê²ƒì„ í™•ì¸ ê°€ëŠ¥
```

<br>

#### 4-4) ê²°ê³¼

![Rviz](../images/ëª…ì„¸ì„œ(2)_images/rviz_result.png)



