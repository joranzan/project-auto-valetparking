# ëª…ì„¸ì„œ 2 
#### ìŠ¤ì¼ˆë ˆí†¤ í”„ë¡œì íŠ¸ (2)
#### ê²½ë¡œ ê´€ë ¨ ì‹¤ìŠµ

<br>

#### ëª©ì°¨
1. [path_maker.py](#1-path_makerpy)
    - [ì½”ë“œ](#1-1-ì½”ë“œ)
    - [ê²°ê³¼](#1-2-ê²°ê³¼)

2. [global_path_pub.py](#2-global_path_pubpy)
    - [To Do](#2-1-to-do)
    - [ì½”ë“œ](#2-2-ì½”ë“œ)
    - [ê²°ê³¼](#2-3-ê²°ê³¼)

3. [local_path_pub.py](#3-local_path_pubpy)
    - [To Do](#3-1-to-do)
    - [ì½”ë“œ](#3-2-ì½”ë“œ)
    - [ê²°ê³¼](#3-3-ê²°ê³¼)
    - [ì‹œê°í™”](#3-4-ì‹œê°í™”)

4. [mgeo_dijkstra_path_1.py](
    #4-mgeo_dijkstra_path_1py)
    - [To Do](#4-1-to-do)
    - [ì½”ë“œ](#4-2-ì½”ë“œ)
    - [ì‹œê°í™”](#4-3-ì‹œê°í™”)
5. [mgeo_dijkstra_path_2.py](#5-mgeo_dijsktra_path_2py)
    - [ì½”ë“œ](#5-1-ì½”ë“œ)
    - [launch íŒŒì¼](#5-2-dijkstra_path_publaunch)
    - [ì‹œê°í™”](#5-3-ì‹œê°í™”)


<br>

---

## 1. path_maker.py

#### 1-1) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-
from re import I
import rospy
import rospkg
from math import sqrt
from geometry_msgs.msg import Point32,PoseStamped
from nav_msgs.msg import Odometry

# path_maker ëŠ” ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ë°ì´í„°ë¥¼ ë°›ì•„ txt íŒŒì¼ë¡œ ì €ì¥í•˜ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.
# ì €ì¥í•œ txt íŒŒì¼ì€ ì°¨ëŸ‰ì˜ ì£¼í–‰ ê²½ë¡œê°€ ë˜ë©° ê²½ë¡œ ê³„íšì— ì´ìš© í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. ì €ì¥í•  ê²½ë¡œ ë° í…ìŠ¤íŠ¸íŒŒì¼ ì´ë¦„ì„ ì •í•˜ê³ , ì“°ê¸° ëª¨ë“œë¡œ ì—´ê¸°
# 2. ì½œë°±í•¨ìˆ˜ì—ì„œ ì²˜ìŒ ë©”ì‹œì§€ê°€ ë“¤ì–´ì˜¤ë©´ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì €ì¥
# 3. ì½œë°±í•¨ìˆ˜ì—ì„œ ì´ì „ ìœ„ì¹˜ì™€ í˜„ì¬ ìœ„ì¹˜ì˜ ê±°ë¦¬ ê³„ì‚°
# 4. ì´ì „ ìœ„ì¹˜ë³´ë‹¤ 0.5m ì´ìƒì¼ ë•Œ ìœ„ì¹˜ë¥¼ ì €ì¥

class pathMaker :    
    def __init__(self, pkg_name = 'ssafy_2', path_name = 'make_path'):
        rospy.init_node('path_maker', anonymous=True)

        rospy.Subscriber("/odom", Odometry, self.odom_callback)

        # ì´ˆê¸°í™”
        self.prev_x = 0
        self.prev_y = 0
        self.is_odom=False

        #(1) ì €ì¥í•  ê²½ë¡œ ë° í…ìŠ¤íŠ¸íŒŒì¼ ì´ë¦„ì„ ì •í•˜ê³ , ì“°ê¸° ëª¨ë“œë¡œ ì—´ê¸°
        
        # Path ë°ì´í„°ë¥¼ ê¸°ë¡ í•˜ê³  ì €ì¥ í•  ê²½ë¡œì™€ txt íŒŒì¼ì˜ ì´ë¦„ì„ ì •í•œë‹¤.
        # ì´í›„ ì“°ê¸° ëª¨ë“œë¡œ ì—°ë‹¤.
        # pkg_name ê³¼ path_name ì€ 22 ë²ˆ ì¤„ ì°¸ê³ í•œë‹¤.
        rospack = rospkg.RosPack()
        pkg_path = rospack.get_path(pkg_name)
        full_path = pkg_path + "/path/" + path_name + ".txt"
        self.f = open(full_path, 'w')

        
        while not rospy.is_shutdown():
            if self.is_odom == True :
                # Ego ìœ„ì¹˜ ê¸°ë¡
                self.path_make()
        self.f.close()

    def path_make(self):
        x = self.x
        y = self.y
        z = 0.0
        #(3) ì½œë°±í•¨ìˆ˜ì—ì„œ ì´ì „ ìœ„ì¹˜ì™€ í˜„ì¬ ìœ„ì¹˜ì˜ ê±°ë¦¬ ê³„ì‚°
        
        # í˜„ì¬ ì°¨ëŸ‰ì˜ ìœ„ì¹˜ì™€ ì´ì „ì— ì§€ë‚˜ì˜¨ ìœ„ì¹˜ì˜ ì¢Œí‘œ ë°ì´í„°ë¥¼ êµ¬í•œë‹¤.
        # êµ¬í•´ì§„ ì¢Œí‘œ ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°í•œë‹¤.
        # ì´ì „ ìœ„ì¹˜ ì¢Œí‘œëŠ” ì•„ë˜ #(4)ì—ì„œ ì •ì˜ í•œë‹¤.
        distance = distance = ((x - self.prev_x) ** 2 + (y - self.prev_y) ** 2) ** 0.5

        

        #(4) ì´ì „ ìœ„ì¹˜ë³´ë‹¤ 0.5m ì´ìƒì¼ ë•Œ ìœ„ì¹˜ë¥¼ ì €ì¥        
        if distance >0.5:
            
            # distance ê°€ 0.5 ë³´ë‹¤ ì»¤ì•¼ì§€ë§Œ ë™ì‘í•œë‹¤.
            # í˜„ì¬ ìœ„ì¹˜ ì¢Œí‘œë¥¼ data ì— ë‹´ì€ ë’¤ txt íŒŒì¼ë¡œ ì‘ì„±í•œë‹¤.
            # data ëŠ” ë¬¸ìì—´ ì´ë©° x y z ì‚¬ì´ëŠ” \t ë¡œ êµ¬ë¶„í•œë‹¤
            data ='{0}\t{1}\t{2}\n'.format(x,y,z)
            self.f.write(data)
            self.prev_x = x
            self.prev_y = y
            #self.prev_z = z
            
            print("Recorded position: ({}, {}, {})", x,y,z)

            

    def odom_callback(self,msg):
        self.is_odom = True
        # (2) ì½œë°±í•¨ìˆ˜ì—ì„œ ì²˜ìŒ ë©”ì‹œì§€ê°€ ë“¤ì–´ì˜¤ë©´ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì €ì¥

        
        # gpsimu_parser.py ì˜ˆì œì—ì„œ Publish í•´ì£¼ëŠ” Odometry ë©”ì„¸ì§€ ë°ì´í„°ë¥¼ Subscrib í•œë‹¤.
        # Odometry ë©”ì„¸ì§€ ì— ë‹´ê¸´ ë¬¼ì²´ì˜ ìœ„ì¹˜ ë°ì´í„°ë¥¼ ì•„ë˜ ë³€ìˆ˜ì— ë„£ì–´ì¤€ë‹¤.
        self.x = msg.pose.pose.position.x
        self.y = msg.pose.pose.position.y

        
if __name__ == '__main__' :
    try:
        p_m=pathMaker()
    except rospy.ROSInternalException:
        pass
            
```

<br>

#### 1-2) ê²°ê³¼

<aside>
ğŸ’¡ ego ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ë³€í™”ê°€ 0.5 ì´ìƒì¼ ë•Œ ìœ„ì¹˜ ì¶œë ¥

</aside>

![PathMaker](../images/ëª…ì„¸ì„œ(2)_images/PathMaker.png
)


<br>

---


## 2. global_path_pub.py

#### 2-1) To Do

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow
from geometry_msgs.msg import Point32,PoseStamped
from nav_msgs.msg import Odometry,Path

# global_path_pub ì€ txt íŒŒì¼ë¡œ ì €ì¥í•œ Path ë°ì´í„°ë¥¼ global Path (ì „ì—­ê²½ë¡œ) ë¡œ ì½ì–´ì˜¤ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.
# ë§Œë“¤ì–´ì§„ global Path(ì „ì—­ê²½ë¡œ) ëŠ” Local Path (ì§€ì—­ê²½ë¡œ) ë¥¼ ë§Œë“œëŠ”ë° ì‚¬ìš© ëœë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. Global Path publisher ì„ ì–¸ ë° Global Path ë³€ìˆ˜ ìƒì„± 
# 2. ì½ì–´ì˜¬ ê²½ë¡œ ì˜ í…ìŠ¤íŠ¸íŒŒì¼ ì´ë¦„ì„ ì •í•˜ê³ , ì½ê¸° ëª¨ë“œë¡œ ì—´ê¸°
# 3. ì½ì–´ ì˜¨ ê²½ë¡œ ë°ì´í„°ë¥¼ Global Path ë³€ìˆ˜ì— ë„£ê¸°
# 4. Global Path ì •ë³´ Publish

class global_path_pub :
    def __init__(self, pkg_name = 'ssafy_2', path_name = 'kcity'):
        rospy.init_node('global_path_pub', anonymous = True)

        #TODO: (1) Global Path publisher ì„ ì–¸ ë° Global Path ë³€ìˆ˜ ìƒì„± 
        '''
        # Global Path ë°ì´í„°ë¥¼ Publish í•˜ëŠ” ë³€ìˆ˜ì™€ ë©”ì„¸ì§€ë¥¼ ë‹´ê³ ìˆëŠ” ë³€ìˆ˜ë¥¼ ì„ ì–¸í•œë‹¤.
        # ì´ë•Œ Global Path ëŠ” map ì¢Œí‘œê³„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒì„±í•œë‹¤.
        self.global_path_pub = 
        self.global_path_msg = 
        self.global_path_msg.header.frame_id = 

        '''

        #TODO: (2) ì½ì–´ì˜¬ ê²½ë¡œ ì˜ í…ìŠ¤íŠ¸íŒŒì¼ ì´ë¦„ì„ ì •í•˜ê³ , ì½ê¸° ëª¨ë“œë¡œ ì—´ê¸°
        '''
        # Path ë°ì´í„°ê°€ ê¸°ë¡ ëœ txt íŒŒì¼ì˜ ê²½ë¡œì™€ ì´ë¦„ì„ ì •í•œë‹¤.
        # ì´í›„ ì½ê¸° ëª¨ë“œë¡œ ì—°ë‹¤.
        # pkg_name ê³¼ path_name ì€ 21 ë²ˆ ì¤„ ì°¸ê³ í•œë‹¤.
        rospack = rospkg.RosPack()
        pkg_path = rospack.get_path(pkg_name)
        full_path = 
        self.f =         
        lines = self.f.readlines()

        '''

        #TODO: (3) ì½ì–´ ì˜¨ ê²½ë¡œ ë°ì´í„°ë¥¼ Global Path ë³€ìˆ˜ì— ë„£ê¸°
        '''
        # ì½ì–´ì˜¨ x y z ì¢Œí‘œ ë°ì´í„°ë¥¼ self.global_path_msg ë³€ìˆ˜ì— ë„£ëŠ”ë‹¤.
        # ë„£ì–´ì¤€ ë°˜ë³µ ë¬¸ì„ ì´ìš©í•˜ì—¬ ì‘ì„±í•œë‹¤.
        for line in lines :
            tmp = line.split()
            read_pose = 
            read_pose.pose.position.x = 
            read_pose.pose.position.y = 
            read_pose.pose.orientation.w = 1
            self.global_path_msg.poses.append(read_pose)        
        self.f.close()

        '''

        rate = rospy.Rate(10) # 10hz
        while not rospy.is_shutdown():
            #TODO: (4) Global Path ì •ë³´ Publish
            '''
            # Global Path ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
            self.global_path_pub.
            
            '''
            rate.sleep()

if __name__ == '__main__':
    try:
        test_track = global_path_pub()
    except rospy.ROSInterruptException:
        pass

```
<br>

#### 2-2) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow
from geometry_msgs.msg import Point32,PoseStamped
from nav_msgs.msg import Odometry,Path

# global_path_pub ì€ txt íŒŒì¼ë¡œ ì €ì¥í•œ Path ë°ì´í„°ë¥¼ global Path (ì „ì—­ê²½ë¡œ) ë¡œ ì½ì–´ì˜¤ëŠ” ì˜ˆì œì…ë‹ˆë‹¤.
# ë§Œë“¤ì–´ì§„ global Path(ì „ì—­ê²½ë¡œ) ëŠ” Local Path (ì§€ì—­ê²½ë¡œ) ë¥¼ ë§Œë“œëŠ”ë° ì‚¬ìš© ëœë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. Global Path publisher ì„ ì–¸ ë° Global Path ë³€ìˆ˜ ìƒì„± 
# 2. ì½ì–´ì˜¬ ê²½ë¡œ ì˜ í…ìŠ¤íŠ¸íŒŒì¼ ì´ë¦„ì„ ì •í•˜ê³ , ì½ê¸° ëª¨ë“œë¡œ ì—´ê¸°
# 3. ì½ì–´ ì˜¨ ê²½ë¡œ ë°ì´í„°ë¥¼ Global Path ë³€ìˆ˜ì— ë„£ê¸°
# 4. Global Path ì •ë³´ Publish

class global_path_pub :
    def __init__(self, pkg_name = 'ssafy_2', path_name = 'kcity'):
        rospy.init_node('global_path_pub', anonymous = True)

        #(1) Global Path publisher ì„ ì–¸ ë° Global Path ë³€ìˆ˜ ìƒì„± 
        
        # Global Path ë°ì´í„°ë¥¼ Publish í•˜ëŠ” ë³€ìˆ˜ì™€ ë©”ì„¸ì§€ë¥¼ ë‹´ê³ ìˆëŠ” ë³€ìˆ˜ë¥¼ ì„ ì–¸í•œë‹¤.
        # ì´ë•Œ Global Path ëŠ” map ì¢Œí‘œê³„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒì„±í•œë‹¤.
        self.global_path_pub = rospy.Publisher("/global_path", Path, queue_size=10)
        self.global_path_msg = Path()
        self.global_path_msg.header.frame_id = "map"

        

        #(2) ì½ì–´ì˜¬ ê²½ë¡œ ì˜ í…ìŠ¤íŠ¸íŒŒì¼ ì´ë¦„ì„ ì •í•˜ê³ , ì½ê¸° ëª¨ë“œë¡œ ì—´ê¸°
        
        # Path ë°ì´í„°ê°€ ê¸°ë¡ ëœ txt íŒŒì¼ì˜ ê²½ë¡œì™€ ì´ë¦„ì„ ì •í•œë‹¤.
        # ì´í›„ ì½ê¸° ëª¨ë“œë¡œ ì—°ë‹¤.
        # pkg_name ê³¼ path_name ì€ 21 ë²ˆ ì¤„ ì°¸ê³ í•œë‹¤.
        rospack = rospkg.RosPack()
        pkg_path = rospack.get_path(pkg_name)
        full_path = pkg_path + "/path/" +path_name + ".txt"
        self.f = open(full_path, 'r')        
        lines = self.f.readlines()

        

        #(3) ì½ì–´ ì˜¨ ê²½ë¡œ ë°ì´í„°ë¥¼ Global Path ë³€ìˆ˜ì— ë„£ê¸°
        
        # ì½ì–´ì˜¨ x y z ì¢Œí‘œ ë°ì´í„°ë¥¼ self.global_path_msg ë³€ìˆ˜ì— ë„£ëŠ”ë‹¤.
        # ë„£ì–´ì¤€ ë°˜ë³µ ë¬¸ì„ ì´ìš©í•˜ì—¬ ì‘ì„±í•œë‹¤.
        for line in lines :
            tmp = line.split()
            read_pose = PoseStamped()
            read_pose.pose.position.x = float(tmp[0])
            read_pose.pose.position.y = float(tmp[1])
            read_pose.pose.orientation.w = 1
            self.global_path_msg.poses.append(read_pose)        
        self.f.close()

        

        rate = rospy.Rate(10) # 10hz
        while not rospy.is_shutdown():
            #(4) Global Path ì •ë³´ Publish
        
            # Global Path ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
            self.global_path_pub.publish(self.global_path_msg)
            
            
            rate.sleep()

if __name__ == '__main__':
    try:
        test_track = global_path_pub()
    except rospy.ROSInterruptException:
        pass

```

<br>

#### 2-3) ê²°ê³¼

![Global Path](../images/ëª…ì„¸ì„œ(2)_images/GlobalPath.png)

<br>

---

## 3. local_path_pub.py

#### 3-1) To Do

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow
from geometry_msgs.msg import Point32,PoseStamped
from nav_msgs.msg import Odometry,Path

# local_path_pub ì€ global Path (ì „ì—­ê²½ë¡œ) ë°ì´í„°ë¥¼ ë°›ì•„ Local Path (ì§€ì—­ê²½ë¡œ) ë¥¼ ë§Œë“œëŠ” ì˜ˆì œì…ë‹ˆë‹¤.
# Local Path (ì§€ì—­ê²½ë¡œ) ëŠ” global Path(ì „ì—­ê²½ë¡œ) ì—ì„œ ì°¨ëŸ‰ê³¼ ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸ë¥¼ ì‹œì‘ìœ¼ë¡œ ë§Œë“¤ì–´ ì§‘ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. Global Path ì™€ Odometry ë°ì´í„° subscriber ìƒì„± 
# 2. Local Path publisher ì„ ì–¸
# 3. Local Path ì˜ Size ê²°ì •
# 4. ì½œë°±í•¨ìˆ˜ì—ì„œ ì²˜ìŒ ë©”ì‹œì§€ê°€ ë“¤ì–´ì˜¤ë©´ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì €ì¥
# 5. Global Path ì—ì„œ ì°¨ëŸ‰ ìœ„ì¹˜ì™€ ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸(Currenty Waypoint) íƒìƒ‰
# 6. ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸(Currenty Waypoint) ìœ„ì¹˜ë¶€í„° Local Path ìƒì„± ë° ì˜ˆì™¸ ì²˜ë¦¬ 
# 7. Local Path ë©”ì„¸ì§€ Publish

class local_path_pub :
    def __init__(self):
        rospy.init_node('local_path_pub', anonymous=True)
        #TODO: (1) Global Path ì™€ Odometry ë°ì´í„° subscriber ìƒì„± 
        '''
        # Global Path ì™€ Odometry ë°ì´í„° subscriber ë¥¼ ìƒì„±í•œë‹¤.
        # ì½œë°± í•¨ìˆ˜ì˜ ì´ë¦„ì€ self.global_path_callback, self.odom_callback ë¡œ í•œë‹¤.
        rospy.Subscriber( odometry ë©”ì„¸ì§€ ì½œë°± ì™„ì„±í•˜ê¸° )
        rospy.Subscriber( global path ë©”ì„¸ì§€ ì½œë°± ì™„ì„±í•˜ê¸° )

        '''

        #TODO: (2) Local Path publisher ì„ ì–¸
        '''
        # local Path ë°ì´í„°ë¥¼ Publish í•˜ëŠ” ë³€ìˆ˜ë¥¼ ì„ ì–¸í•œë‹¤.
        self.local_path_pub = rospy.Publisher('/local_path',Path, queue_size=1)

        '''
        
        # ì´ˆê¸°í™”
        self.is_odom = False
        self.is_path = False

        #TODO: (3) Local Path ì˜ Size ê²°ì •
        '''
        # Local Path ì˜ í¬ê¸°ë¥¼ ì§€ì •í•œë‹¤.
        # ì°¨ëŸ‰ì´ ì£¼í–‰ ì‹œ Local Path ì˜ í¬ê¸° ë§Œí¼ì˜ ì •ë³´ë¥¼ ê°€ì§€ê³  ì£¼í–‰í•˜ê²Œ ëœë‹¤
        # ë„ˆë¬´ ì‘ì§€ë„ í¬ê¸°ì§€ë„ ì•Šì€ ê°’ì„ ì‚¬ìš©í•œë‹¤ (50 ~ 200)
        self.local_path_size = 

        '''
        rate = rospy.Rate(20) # 20hz
        while not rospy.is_shutdown():
   
            if self.is_odom == True and self.is_path == True:
                local_path_msg=Path()
                local_path_msg.header.frame_id='/map'
                
                x=self.x
                y=self.y

                #TODO: (5) Global Path ì—ì„œ ì°¨ëŸ‰ ìœ„ì¹˜ì™€ ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸(current Waypoint) íƒìƒ‰
                '''
                # global Path ì—ì„œ ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
                # í˜„ì œ ìœ„ì¹˜ëŠ” WayPoint ë¡œ ê¸°ë¡í•˜ë©° í˜„ì¬ ì°¨ëŸ‰ì´ Path ì—ì„œ ëª‡ë²ˆ ì§¸ ìœ„ì¹˜ì— ìˆëŠ”ì§€ ë‚˜íƒ€ë‚´ëŠ” ê°’ì´ ë©ë‹ˆë‹¤.
                # ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ëŠ” Local Path ë¥¼ ë§Œë“œëŠ” ì‹œì‘ ìœ„ì¹˜ê°€ ë©ë‹ˆë‹¤.
                # ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ë¥¼ íƒìƒ‰í•˜ëŠ” ë°˜ë³µë¬¸ì€ ì‘ì„±í•´ current_waypoint ì°¾ìŠµë‹ˆë‹¤.
                min_dis = float('inf')
                current_waypoint = -1
                for  in  :

                '''
                
                #TODO: (6) ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸(current Waypoint) ìœ„ì¹˜ë¶€í„° Local Path ìƒì„± ë° ì˜ˆì™¸ ì²˜ë¦¬
                '''
                # ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ ë¶€í„° local_path_size ë¡œ ì§€ì •í•œ Path ì˜ í¬ê¸° ë§Œí¼ì˜ Path local_path ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
                # ì°¨ëŸ‰ì— ë‚¨ì€ Path ì˜ ê¸¸ì´ê°€ local_path_size ë³´ë‹¤ ì‘ì€ ê²½ìš°ê°€ ìˆìŒìœ¼ë¡œ ì¡°ê±´ ë¬¸ì„ ì´ìš©í•˜ì—¬ í•´ë‹¹ ì¡°ê±´ì„ ì˜ˆì™¸ ì²˜ë¦¬ í•©ë‹ˆë‹¤.
                if current_waypoint != -1 :
                    if current_waypoint + self.local_path_size < len(self.global_path_msg.poses):
                    
                    else :

                '''

                print(x,y)
                #TODO: (7) Local Path ë©”ì„¸ì§€ Publish
                '''
                # Local Path ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.local_path_pub.
                
                '''

            rate.sleep()

    def odom_callback(self,msg):
        self.is_odom = True
        #TODO: (4) ì½œë°±í•¨ìˆ˜ì—ì„œ ì²˜ìŒ ë©”ì‹œì§€ê°€ ë“¤ì–´ì˜¤ë©´ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì €ì¥

        '''
        # gpsimu_parser.py ì˜ˆì œì—ì„œ Publish í•´ì£¼ëŠ” Odometry ë©”ì„¸ì§€ ë°ì´í„°ë¥¼ Subscrib í•œë‹¤.
        # Odometry ë©”ì„¸ì§€ ì— ë‹´ê¸´ ë¬¼ì²´ì˜ ìœ„ì¹˜ ë°ì´í„°ë¥¼ ì•„ë˜ ë³€ìˆ˜ì— ë„£ì–´ì¤€ë‹¤.
        self.x = ë¬¼ì²´ì˜ x ì¢Œí‘œ 
        self.y = ë¬¼ì²´ì˜ y ì¢Œí‘œ

        '''

    def global_path_callback(self,msg):
        self.is_path = True
        self.global_path_msg = msg        

if __name__ == '__main__':
    try:
        test_track=local_path_pub()
    except rospy.ROSInterruptException:
        pass

```

<br>

#### 3-2) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow
from geometry_msgs.msg import Point32,PoseStamped
from nav_msgs.msg import Odometry,Path

# local_path_pub ì€ global Path (ì „ì—­ê²½ë¡œ) ë°ì´í„°ë¥¼ ë°›ì•„ Local Path (ì§€ì—­ê²½ë¡œ) ë¥¼ ë§Œë“œëŠ” ì˜ˆì œì…ë‹ˆë‹¤.
# Local Path (ì§€ì—­ê²½ë¡œ) ëŠ” global Path(ì „ì—­ê²½ë¡œ) ì—ì„œ ì°¨ëŸ‰ê³¼ ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸ë¥¼ ì‹œì‘ìœ¼ë¡œ ë§Œë“¤ì–´ ì§‘ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 1. Global Path ì™€ Odometry ë°ì´í„° subscriber ìƒì„± 
# 2. Local Path publisher ì„ ì–¸
# 3. Local Path ì˜ Size ê²°ì •
# 4. ì½œë°±í•¨ìˆ˜ì—ì„œ ì²˜ìŒ ë©”ì‹œì§€ê°€ ë“¤ì–´ì˜¤ë©´ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì €ì¥
# 5. Global Path ì—ì„œ ì°¨ëŸ‰ ìœ„ì¹˜ì™€ ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸(Currenty Waypoint) íƒìƒ‰
# 6. ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸(Currenty Waypoint) ìœ„ì¹˜ë¶€í„° Local Path ìƒì„± ë° ì˜ˆì™¸ ì²˜ë¦¬ 
# 7. Local Path ë©”ì„¸ì§€ Publish

class local_path_pub :
    def __init__(self):
        rospy.init_node('local_path_pub', anonymous=True)
        #(1) Global Path ì™€ Odometry ë°ì´í„° subscriber ìƒì„± 
        
        # Global Path ì™€ Odometry ë°ì´í„° subscriber ë¥¼ ìƒì„±í•œë‹¤.
        # ì½œë°± í•¨ìˆ˜ì˜ ì´ë¦„ì€ self.global_path_callback, self.odom_callback ë¡œ í•œë‹¤.
        rospy.Subscriber( '/odom', Odometry, self.odom_callback )
        rospy.Subscriber( '/global_path', Path, self.global_path_callback )

        

        #(2) Local Path publisher ì„ ì–¸
        
        # local Path ë°ì´í„°ë¥¼ Publish í•˜ëŠ” ë³€ìˆ˜ë¥¼ ì„ ì–¸í•œë‹¤.
        self.local_path_pub = rospy.Publisher('/local_path',Path, queue_size=1)
        
        
        # ì´ˆê¸°í™”
        self.is_odom = False
        self.is_path = False

        #(3) Local Path ì˜ Size ê²°ì •
        
        # Local Path ì˜ í¬ê¸°ë¥¼ ì§€ì •í•œë‹¤.
        # ì°¨ëŸ‰ì´ ì£¼í–‰ ì‹œ Local Path ì˜ í¬ê¸° ë§Œí¼ì˜ ì •ë³´ë¥¼ ê°€ì§€ê³  ì£¼í–‰í•˜ê²Œ ëœë‹¤
        # ë„ˆë¬´ ì‘ì§€ë„ í¬ê¸°ì§€ë„ ì•Šì€ ê°’ì„ ì‚¬ìš©í•œë‹¤ (50 ~ 200)
        self.local_path_size = 100

        
        rate = rospy.Rate(20) # 20hz
        while not rospy.is_shutdown():
   
            if self.is_odom == True and self.is_path == True:
                local_path_msg=Path()
                local_path_msg.header.frame_id='/map'
                
                x=self.x
                y=self.y

                # (5) Global Path ì—ì„œ ì°¨ëŸ‰ ìœ„ì¹˜ì™€ ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸(current Waypoint) íƒìƒ‰
                
                # global Path ì—ì„œ ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
                # í˜„ì œ ìœ„ì¹˜ëŠ” WayPoint ë¡œ ê¸°ë¡í•˜ë©° í˜„ì¬ ì°¨ëŸ‰ì´ Path ì—ì„œ ëª‡ë²ˆ ì§¸ ìœ„ì¹˜ì— ìˆëŠ”ì§€ ë‚˜íƒ€ë‚´ëŠ” ê°’ì´ ë©ë‹ˆë‹¤.
                # ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ëŠ” Local Path ë¥¼ ë§Œë“œëŠ” ì‹œì‘ ìœ„ì¹˜ê°€ ë©ë‹ˆë‹¤.
                # ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ë¥¼ íƒìƒ‰í•˜ëŠ” ë°˜ë³µë¬¸ì€ ì‘ì„±í•´ current_waypoint ì°¾ìŠµë‹ˆë‹¤.
                min_dis = float('inf')
                current_waypoint = -1
                for i,pose in enumerate(self.global_path_msg.poses) :
                    dis = sqrt((x - pose.pose.position.x)**2 + (y - pose.pose.position.y)**2)
                    if dis < min_dis:
                        min_dis = dis
                        current_waypoint = i
                

                
                
                # (6) ê°€ì¥ ê°€ê¹Œìš´ í¬ì¸íŠ¸(current Waypoint) ìœ„ì¹˜ë¶€í„° Local Path ìƒì„± ë° ì˜ˆì™¸ ì²˜ë¦¬
                
                # ì°¨ëŸ‰ì˜ í˜„ì¬ ìœ„ì¹˜ ë¶€í„° local_path_size ë¡œ ì§€ì •í•œ Path ì˜ í¬ê¸° ë§Œí¼ì˜ Path local_path ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
                # ì°¨ëŸ‰ì— ë‚¨ì€ Path ì˜ ê¸¸ì´ê°€ local_path_size ë³´ë‹¤ ì‘ì€ ê²½ìš°ê°€ ìˆìŒìœ¼ë¡œ ì¡°ê±´ ë¬¸ì„ ì´ìš©í•˜ì—¬ í•´ë‹¹ ì¡°ê±´ì„ ì˜ˆì™¸ ì²˜ë¦¬ í•©ë‹ˆë‹¤.
                if current_waypoint != -1 :
                    if current_waypoint + self.local_path_size < len(self.global_path_msg.poses):
                        local_path_msg.poses = self.global_path_msg.poses[current_waypoint:current_waypoint+self.local_path_size]
                    else :
                        local_path_msg.poses = self.global_path_msg.poses[current_waypoint:]

                

                print(x,y)
                #(7) Local Path ë©”ì„¸ì§€ Publish
                
                # Local Path ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.local_path_pub.publish(local_path_msg)
            rate.sleep()

    def odom_callback(self,msg):
        self.is_odom = True
        #(4) ì½œë°±í•¨ìˆ˜ì—ì„œ ì²˜ìŒ ë©”ì‹œì§€ê°€ ë“¤ì–´ì˜¤ë©´ ì´ˆê¸° ìœ„ì¹˜ë¥¼ ì €ì¥

        
        # gpsimu_parser.py ì˜ˆì œì—ì„œ Publish í•´ì£¼ëŠ” Odometry ë©”ì„¸ì§€ ë°ì´í„°ë¥¼ Subscrib í•œë‹¤.
        # Odometry ë©”ì„¸ì§€ ì— ë‹´ê¸´ ë¬¼ì²´ì˜ ìœ„ì¹˜ ë°ì´í„°ë¥¼ ì•„ë˜ ë³€ìˆ˜ì— ë„£ì–´ì¤€ë‹¤.
        self.x = msg.pose.pose.position.x
        self.y = msg.pose.pose.position.y

        

    def global_path_callback(self,msg):
        self.is_path = True
        self.global_path_msg = msg        

if __name__ == '__main__':
    try:
        test_track=local_path_pub()
    except rospy.ROSInterruptException:
        pass

```

<br>

#### 3-3) ê²°ê³¼

![Local Path](../images/ëª…ì„¸ì„œ(2)_images/LocalPath_Result.png)

<br>

#### 3-4) ì‹œê°í™”

```python
$ roslaunch ssafy_2 path_pub.launch
```

- ì´ˆë¡ìƒ‰ : Global Path
- ë¹¨ê°„ìƒ‰ : Local Path

![LocalPath-1](../images/ëª…ì„¸ì„œ(2)_images/LocalPath-1.png)

![LocalPath-2](../images/ëª…ì„¸ì„œ(2)_images/LocalPath-2.png)

<br>


---

## 4. mgeo_dijkstra_path_1.py

#### 4-1) To Do

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
import sys
import os
import copy
import numpy as np
import json

from math import cos,sin,sqrt,pow,atan2,pi
from geometry_msgs.msg import Point32,PoseStamped
from nav_msgs.msg import Odometry,Path

current_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(current_path)

from lib.mgeo.class_defs import *

# mgeo_dijkstra_path_1 ì€ Mgeo ë°ì´í„°ë¥¼ ì´ìš©í•˜ì—¬ ì‹œì‘ Node ì™€ ëª©ì ì§€ Node ë¥¼ ì§€ì •í•˜ì—¬ Dijkstra ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ëŠ” ì˜ˆì œ ì…ë‹ˆë‹¤.
# ì‚¬ìš©ìê°€ ì§ì ‘ ì§€ì •í•œ ì‹œì‘ Node ì™€ ëª©ì ì§€ Node ì‚¬ì´ ìµœë‹¨ ê²½ë¡œ ê³„ì‚°í•˜ì—¬ global Path(ì „ì—­ê²½ë¡œ) ë¥¼ ìƒì„± í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸
# 2. ì‹œì‘ Node ì™€ ì¢…ë£Œ Node ì •ì˜
# 3. weight ê°’ ê³„ì‚°
# 4. Dijkstra Path ì´ˆê¸°í™” ë¡œì§
# 5. Dijkstra í•µì‹¬ ì½”ë“œ
# 6. node path ìƒì„±
# 7. link path ìƒì„±
# 8. Result íŒë³„
# 9. point path ìƒì„±
# 10. dijkstra ê²½ë¡œ ë°ì´í„°ë¥¼ ROS Path ë©”ì„¸ì§€ í˜•ì‹ì— ë§ì¶° ì •ì˜
# 11. dijkstra ì´ìš©í•´ ë§Œë“  Global Path ì •ë³´ Publish

#TODO: (0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹
'''
# dijkstra ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ë˜í”„ êµ¬ì¡°ì—ì„œ ë…¸ë“œ ê°„ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ ì…ë‹ˆë‹¤.
# ì‹œì‘ ë…¸ë“œë¶€í„° ë‹¤ë¥¸ ëª¨ë“  ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.
# ë‹¤ì–‘í•œ ì„œë¹„ìŠ¤ì—ì„œ ì‹¤ì œë¡œ ì‚¬ìš© ë˜ë©° ì¸ê³µ ìœ„ì„±ì—ë„ ì‚¬ìš©ë˜ëŠ” ë°©ì‹ ì…ë‹ˆë‹¤.
# ì „ì²´ ë™ì‘ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
#
# 1. ì‹œì‘ ë…¸ë“œ ì§€ì •
# 2. ì‹œì‘ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ë¥¸ ë…¸ë“œì™€ì˜ ë¹„ìš©ì„ ì €ì¥(ê²½ë¡œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” ë¹„ìš©ì´ë€ ê²½ë¡œì˜ í¬ê¸°ë¥¼ ì˜ë¯¸)
# 3. ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë“¤ ì¤‘ ê°€ì¥ ì ì€ ë¹„ìš©ì˜ ë…¸ë“œë¥¼ ë°©ë¬¸
# 4. ë°©ë¬¸í•œ ë…¸ë“œì™€ ì¸ì ‘í•œ ë…¸ë“œë“¤ì„ ì¡°ì‚¬í•´ì„œ ìƒˆë¡œ ì¡°ì‚¬ëœ ìµœë‹¨ ê±°ë¦¬ê°€ ê¸°ì¡´ ë°œê²¬ëœ ìµœë‹¨ê±°ë¦¬ ë³´ë‹¤ ì‘ìœ¼ë©´ ì •ë³´ë¥¼ ê°±ì‹ 
#   [   ìƒˆë¡œ ì¡°ì‚¬ëœ ìµœë‹¨ ê±°ë¦¬ : ì‹œì‘ ë…¸ë“œì—ì„œ ë°©ë¬¸ ë…¸ë“œ ê¹Œì§€ì˜ ê±°ë¦¬ ë¹„ìš© + ë°©ë¬¸ ë…¸ë“œì—ì„œ ì¸ì ‘ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ ë¹„ìš©    ]
#   [   ê¸°ì¡´ ë°œê²¬ëœ ìµœë‹¨ ê±°ë¦¬ : ì‹œì‘ ë…¸ë“œì—ì„œ ì¸ì ‘ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ ë¹„ìš©                                       ]
# 5. 3 ~ 4 ê³¼ì •ì„ ë°˜ë³µ 
# 

'''
class dijkstra_path_pub :
    def __init__(self):
        rospy.init_node('dijkstra_path_pub', anonymous=True)

        self.global_path_pub = rospy.Publisher('/global_path',Path, queue_size = 1)

        #TODO: (1) Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸
        load_path = os.path.normpath(os.path.join(current_path, 'lib/mgeo_data/R_KR_PG_K-City'))
        mgeo_planner_map = MGeo.create_instance_from_json(load_path)

        node_set = mgeo_planner_map.node_set
        link_set = mgeo_planner_map.link_set

        self.nodes=node_set.nodes
        self.links=link_set.lines

        self.global_planner=Dijkstra(self.nodes,self.links)

        #TODO: (2) ì‹œì‘ Node ì™€ ì¢…ë£Œ Node ì •ì˜
        '''
        # Dijkstra Path ë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ì¶œë°œ Node ì™€ ë„ì°© Nodeì˜ Idx ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        # MGeo ë°ì´í„°ëŠ” Json íŒŒì¼ë¡œ Idx ì •ë³´ë¥¼ í™•ì¸ í•  ìˆ˜ ìˆì§€ë§Œ ì‹œë®¬ë ˆì´í„°ë¥¼ í†µí•´ ì§ì ‘ í™•ì¸ ê°€ëŠ¥í•©ë‹ˆë‹¤.
        # F8 í‚¤ë³´ë“œ ì…ë ¥ ë˜ëŠ” ì‹œë®¬ë ˆì´í„°ì—ì„œ í™”ë©´ ì¢Œì¸¡ ìƒë‹¨ì— View --> MGeo Viewer ë¥¼ í´ë¦­í•©ë‹ˆë‹¤.
        # MGeo Viewer ê¸°ëŠ¥ì„ ì´ìš©í•˜ì—¬ ë§µì—ìˆëŠ” MGeo ì •ë³´ë¥¼ í™•ì¸ í•  ìˆ˜ ìˆìœ¼ë©° ì‹œê°í™” ê¹Œì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
        # í•´ë‹¹ ê¸°ëŠ¥ì„ ì´ìš©í•˜ì—¬ ì›í•˜ëŠ” ì‹œì‘ ìœ„ì¹˜ì™€ ì¢…ë£Œ ìœ„ì¹˜ì˜ Node ì´ë¦„ì„ ì•Œì•„ë‚¸ ë’¤ ì•„ë˜ ë³€ìˆ˜ì— ì…ë ¥í•˜ì„¸ìš”.
        
        self.start_node = 'A119BS010184'
        self.end_node = 'A119BS010148'

        '''

        self.global_path_msg = Path()
        self.global_path_msg.header.frame_id = '/map'

        self.global_path_msg = self.calc_dijkstra_path_node(self.start_node, self.end_node)

        rate = rospy.Rate(10) # 10hz
        while not rospy.is_shutdown():
            #TODO: (11) dijkstra ì´ìš©í•´ ë§Œë“  Global Path ì •ë³´ Publish
            '''
            # dijkstra ì´ìš©í•´ ë§Œë“  Global Path ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
            self.global_path_pub.
            
            '''
            rate.sleep()

    def calc_dijkstra_path_node(self, start_node, end_node):

        result, path = self.global_planner.find_shortest_path(start_node, end_node)

        #TODO: (10) dijkstra ê²½ë¡œ ë°ì´í„°ë¥¼ ROS Path ë©”ì„¸ì§€ í˜•ì‹ì— ë§ì¶° ì •ì˜
        out_path = Path()
        out_path.header.frame_id = '/map'
        '''
        # dijkstra ê²½ë¡œ ë°ì´í„° ì¤‘ Point ì •ë³´ë¥¼ ì´ìš©í•˜ì—¬ Path ë°ì´í„°ë¥¼ ë§Œë“¤ì–´ ì¤ë‹ˆë‹¤.

        '''

        return out_path

class Dijkstra:
    def __init__(self, nodes, links):
        self.nodes = nodes
        self.links = links
        #TODO: (3) weight ê°’ ê³„ì‚°
        self.weight = self.get_weight_matrix()
        self.lane_change_link_idx = []

    def get_weight_matrix(self):
        #TODO: (3) weight ê°’ ê³„ì‚°
        '''
        # weight ê°’ ê³„ì‚°ì€ ê° Node ì—ì„œ ì¸ì ‘ í•œ ë‹¤ë¥¸ Node ê¹Œì§€ì˜ ë¹„ìš©ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
        # ê³„ì‚°ëœ weight ê°’ ì€ ê° ë…¸ë“œê°„ ì´ë™ì‹œ ë°œìƒí•˜ëŠ” ë¹„ìš©(ê±°ë¦¬)ì„ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì—
        # Dijkstra íƒìƒ‰ì—ì„œ ì¤‘ìš”í•˜ê²Œ ì‚¬ìš© ë©ë‹ˆë‹¤.
        # weight ê°’ì€ ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ì‚¬ìš© í•©ë‹ˆë‹¤.
        # ì´ì¤‘ ì¤‘ì²©ëœ ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ì‚¬ìš©í•˜ë©° 
        # Key ê°’ìœ¼ë¡œ Nodeì˜ Idx Value ê°’ìœ¼ë¡œ ë‹¤ë¥¸ ë…¸ë“œ ê¹Œì§€ì˜ ë¹„ìš©ì„ ê°€ì§€ë„ë¡ í•©ë‹ˆë‹¤.
        # ì•„ë˜ ì½”ë“œ ì¤‘ self.find_shortest_link_leading_to_node ë¥¼ ì™„ì„±í•˜ì—¬ 
        # Dijkstra ì•Œê³ ë¦¬ì¦˜ ê³„ì‚°ì„ ìœ„í•œ Nodeì™€ Node ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

        '''
        # ì´ˆê¸° ì„¤ì •
        weight = dict() 
        for from_node_id, from_node in self.nodes.items():
            # í˜„ì¬ ë…¸ë“œì—ì„œ ë‹¤ë¥¸ ë…¸ë“œë¡œ ì§„í–‰í•˜ëŠ” ëª¨ë“  weight
            weight_from_this_node = dict()
            for to_node_id, to_node in self.nodes.items():
                weight_from_this_node[to_node_id] = float('inf')
            # ì „ì²´ weight matrixì— ì¶”ê°€
            weight[from_node_id] = weight_from_this_node

        for from_node_id, from_node in self.nodes.items():
            # í˜„ì¬ ë…¸ë“œì—ì„œ í˜„ì¬ ë…¸ë“œë¡œëŠ” cost = 0
            weight[from_node_id][from_node_id] = 0

            for to_node in from_node.get_to_nodes():
                # í˜„ì¬ ë…¸ë“œì—ì„œ to_nodeë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ë§í¬ë¥¼ ì°¾ê³ , ê·¸ ì¤‘ì—ì„œ ê°€ì¥ ë¹ ë¥¸ ë§í¬ë¥¼ ì°¾ì•„ì¤€ë‹¤
                shortest_link, min_cost = self.find_shortest_link_leading_to_node(from_node,to_node)
                weight[from_node_id][to_node.idx] = min_cost           

        return weight

    def find_shortest_link_leading_to_node(self, from_node,to_node):
        """í˜„ì¬ ë…¸ë“œì—ì„œ to_nodeë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ë§í¬ë¥¼ ì°¾ê³ , ê·¸ ì¤‘ì—ì„œ ê°€ì¥ ë¹ ë¥¸ ë§í¬ë¥¼ ì°¾ì•„ì¤€ë‹¤"""
        #TODO: (3) weight ê°’ ê³„ì‚°
        '''
        # ìµœë‹¨ê±°ë¦¬ Link ì¸ shortest_link ë³€ìˆ˜ì™€
        # shortest_link ì˜ min_cost ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.

        '''

        return shortest_link, min_cost
        
    def find_nearest_node_idx(self, distance, s):        
        idx_list = self.nodes.keys()
        min_value = float('inf')
        min_idx = idx_list[-1]

        for idx in idx_list:
            if distance[idx] < min_value and s[idx] == False :
                min_value = distance[idx]
                min_idx = idx
        return min_idx

    def find_shortest_path(self, start_node_idx, end_node_idx): 
        #TODO: (4) Dijkstra Path ì´ˆê¸°í™” ë¡œì§
        # s ì´ˆê¸°í™”         >> s = [False] * len(self.nodes)
        # from_node ì´ˆê¸°í™” >> from_node = [start_node_idx] * len(self.nodes)
        '''
        # Dijkstra ê²½ë¡œ íƒìƒ‰ì„ ìœ„í•œ ì´ˆê¸°í™” ë¡œì§ ì…ë‹ˆë‹¤.
        # ë³€ìˆ˜ sì™€ from_node ëŠ” ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ í¬ê¸°ë¥¼ MGeoì˜ Node ì˜ ê°œìˆ˜ë¡œ ì„¤ì •í•©ë‹ˆë‹¤. 
        # Dijkstra ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ íƒìƒ‰ í•œ Node ëŠ” ë³€ìˆ˜ s ì— True ë¡œ íƒìƒ‰í•˜ì§€ ì•Šì€ ë³€ìˆ˜ëŠ” False ë¡œ í•©ë‹ˆë‹¤.
        # from_node ì˜ Key ê°’ì€ Node ì˜ Idxë¡œ
        # from_node ì˜ Value ê°’ì€ Key ê°’ì˜ Node Idx ì—ì„œ ê°€ì¥ ë¹„ìš©ì´ ì‘ì€(ê°€ì¥ ê°€ê¹Œìš´) Node Idxë¡œ í•©ë‹ˆë‹¤.
        # from_node í†µí•´ ê° Node ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ Node ì°¾ê³ 
        # ì´ë¥¼ ì—°ê²°í•´ ì‹œì‘ ë…¸ë“œë¶€í„° ë„ì°© ë…¸ë“œ ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤. 

        '''
        s = dict()
        from_node = dict() 
        for node_id in self.nodes.keys():
            s[node_id] = False
            from_node[node_id] = start_node_idx

        s[start_node_idx] = True
        distance =copy.deepcopy(self.weight[start_node_idx])

        #TODO: (5) Dijkstra í•µì‹¬ ì½”ë“œ
        for i in range(len(self.nodes.keys()) - 1):
            selected_node_idx = self.find_nearest_node_idx(distance, s)
            s[selected_node_idx] = True            
            for j, to_node_idx in enumerate(self.nodes.keys()):
                if s[to_node_idx] == False:
                    distance_candidate = distance[selected_node_idx] + self.weight[selected_node_idx][to_node_idx]
                    if distance_candidate < distance[to_node_idx]:
                        distance[to_node_idx] = distance_candidate
                        from_node[to_node_idx] = selected_node_idx

        #TODO: (6) node path ìƒì„±
        tracking_idx = end_node_idx
        node_path = [end_node_idx]
        
        while start_node_idx != tracking_idx:
            tracking_idx = from_node[tracking_idx]
            node_path.append(tracking_idx)     

        node_path.reverse()

        #TODO: (7) link path ìƒì„±
        link_path = []
        for i in range(len(node_path) - 1):
            from_node_idx = node_path[i]
            to_node_idx = node_path[i + 1]

            from_node = self.nodes[from_node_idx]
            to_node = self.nodes[to_node_idx]

            shortest_link, min_cost = self.find_shortest_link_leading_to_node(from_node,to_node)
            link_path.append(shortest_link.idx)

        #TODO: (8) Result íŒë³„
        if len(link_path) == 0:
            return False, {'node_path': node_path, 'link_path':link_path, 'point_path':[]}

        #TODO: (9) point path ìƒì„±
        point_path = []        
        for link_id in link_path:
            link = self.links[link_id]
            for point in link.points:
                point_path.append([point[0], point[1], 0])

        return True, {'node_path': node_path, 'link_path':link_path, 'point_path':point_path}

if __name__ == '__main__':
    
    dijkstra_path_pub = dijkstra_path_pub()


```

<br>


#### 4-2) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
import sys
import os
import copy
import numpy as np
import json

from math import cos,sin,sqrt,pow,atan2,pi
from geometry_msgs.msg import Point32,PoseStamped
from nav_msgs.msg import Odometry,Path

current_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(current_path)

from lib.mgeo.class_defs import *

# mgeo_dijkstra_path_1 ì€ Mgeo ë°ì´í„°ë¥¼ ì´ìš©í•˜ì—¬ ì‹œì‘ Node ì™€ ëª©ì ì§€ Node ë¥¼ ì§€ì •í•˜ì—¬ Dijkstra ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ëŠ” ì˜ˆì œ ì…ë‹ˆë‹¤.
# ì‚¬ìš©ìê°€ ì§ì ‘ ì§€ì •í•œ ì‹œì‘ Node ì™€ ëª©ì ì§€ Node ì‚¬ì´ ìµœë‹¨ ê²½ë¡œ ê³„ì‚°í•˜ì—¬ global Path(ì „ì—­ê²½ë¡œ) ë¥¼ ìƒì„± í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸
# 2. ì‹œì‘ Node ì™€ ì¢…ë£Œ Node ì •ì˜
# 3. weight ê°’ ê³„ì‚°
# 4. Dijkstra Path ì´ˆê¸°í™” ë¡œì§
# 5. Dijkstra í•µì‹¬ ì½”ë“œ
# 6. node path ìƒì„±
# 7. link path ìƒì„±
# 8. Result íŒë³„
# 9. point path ìƒì„±
# 10. dijkstra ê²½ë¡œ ë°ì´í„°ë¥¼ ROS Path ë©”ì„¸ì§€ í˜•ì‹ì— ë§ì¶° ì •ì˜
# 11. dijkstra ì´ìš©í•´ ë§Œë“  Global Path ì •ë³´ Publish

# (0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹

# dijkstra ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ë˜í”„ êµ¬ì¡°ì—ì„œ ë…¸ë“œ ê°„ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ ì…ë‹ˆë‹¤.
# ì‹œì‘ ë…¸ë“œë¶€í„° ë‹¤ë¥¸ ëª¨ë“  ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.
# ë‹¤ì–‘í•œ ì„œë¹„ìŠ¤ì—ì„œ ì‹¤ì œë¡œ ì‚¬ìš© ë˜ë©° ì¸ê³µ ìœ„ì„±ì—ë„ ì‚¬ìš©ë˜ëŠ” ë°©ì‹ ì…ë‹ˆë‹¤.
# ì „ì²´ ë™ì‘ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
#
# 1. ì‹œì‘ ë…¸ë“œ ì§€ì •
# 2. ì‹œì‘ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ë¥¸ ë…¸ë“œì™€ì˜ ë¹„ìš©ì„ ì €ì¥(ê²½ë¡œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” ë¹„ìš©ì´ë€ ê²½ë¡œì˜ í¬ê¸°ë¥¼ ì˜ë¯¸)
# 3. ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë“¤ ì¤‘ ê°€ì¥ ì ì€ ë¹„ìš©ì˜ ë…¸ë“œë¥¼ ë°©ë¬¸
# 4. ë°©ë¬¸í•œ ë…¸ë“œì™€ ì¸ì ‘í•œ ë…¸ë“œë“¤ì„ ì¡°ì‚¬í•´ì„œ ìƒˆë¡œ ì¡°ì‚¬ëœ ìµœë‹¨ ê±°ë¦¬ê°€ ê¸°ì¡´ ë°œê²¬ëœ ìµœë‹¨ê±°ë¦¬ ë³´ë‹¤ ì‘ìœ¼ë©´ ì •ë³´ë¥¼ ê°±ì‹ 
#   [   ìƒˆë¡œ ì¡°ì‚¬ëœ ìµœë‹¨ ê±°ë¦¬ : ì‹œì‘ ë…¸ë“œì—ì„œ ë°©ë¬¸ ë…¸ë“œ ê¹Œì§€ì˜ ê±°ë¦¬ ë¹„ìš© + ë°©ë¬¸ ë…¸ë“œì—ì„œ ì¸ì ‘ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ ë¹„ìš©    ]
#   [   ê¸°ì¡´ ë°œê²¬ëœ ìµœë‹¨ ê±°ë¦¬ : ì‹œì‘ ë…¸ë“œì—ì„œ ì¸ì ‘ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ ë¹„ìš©                                       ]
# 5. 3 ~ 4 ê³¼ì •ì„ ë°˜ë³µ 
# 

class dijkstra_path_pub :
    def __init__(self, start_node='A119BS010184', end_node='A119BS010148'):
        rospy.init_node('dijkstra_path_pub', anonymous=True)

        self.global_path_pub = rospy.Publisher('/global_path',Path, queue_size = 1)

        # (1) Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸
        load_path = os.path.normpath(os.path.join(current_path, 'lib/mgeo_data/R_KR_PG_K-City'))
        mgeo_planner_map = MGeo.create_instance_from_json(load_path)

        node_set = mgeo_planner_map.node_set
        link_set = mgeo_planner_map.link_set

        self.nodes=node_set.nodes
        self.links=link_set.lines
        #self.links = {link.idx: link for link in link_set.lines}  # ë§í¬ ê°ì²´ë¥¼ ìš”ì†Œë¡œ ê°€ì§€ëŠ” ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜

        print('# of nodes: ', len(node_set.nodes))
        print('# of links: ', len(link_set.lines))

        self.global_planner=Dijkstra(self.nodes,self.links)

        #2) ì‹œì‘ Node ì™€ ì¢…ë£Œ Node ì •ì˜
        
        # Dijkstra Path ë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ì¶œë°œ Node ì™€ ë„ì°© Nodeì˜ Idx ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        # MGeo ë°ì´í„°ëŠ” Json íŒŒì¼ë¡œ Idx ì •ë³´ë¥¼ í™•ì¸ í•  ìˆ˜ ìˆì§€ë§Œ ì‹œë®¬ë ˆì´í„°ë¥¼ í†µí•´ ì§ì ‘ í™•ì¸ ê°€ëŠ¥í•©ë‹ˆë‹¤.
        # F8 í‚¤ë³´ë“œ ì…ë ¥ ë˜ëŠ” ì‹œë®¬ë ˆì´í„°ì—ì„œ í™”ë©´ ì¢Œì¸¡ ìƒë‹¨ì— View --> MGeo Viewer ë¥¼ í´ë¦­í•©ë‹ˆë‹¤.
        # MGeo Viewer ê¸°ëŠ¥ì„ ì´ìš©í•˜ì—¬ ë§µì—ìˆëŠ” MGeo ì •ë³´ë¥¼ í™•ì¸ í•  ìˆ˜ ìˆìœ¼ë©° ì‹œê°í™” ê¹Œì§€ ê°€ëŠ¥í•©ë‹ˆë‹¤.
        # í•´ë‹¹ ê¸°ëŠ¥ì„ ì´ìš©í•˜ì—¬ ì›í•˜ëŠ” ì‹œì‘ ìœ„ì¹˜ì™€ ì¢…ë£Œ ìœ„ì¹˜ì˜ Node ì´ë¦„ì„ ì•Œì•„ë‚¸ ë’¤ ì•„ë˜ ë³€ìˆ˜ì— ì…ë ¥í•˜ì„¸ìš”.
        
        self.start_node = start_node
        self.end_node = end_node

        

        self.global_path_msg = Path()
        self.global_path_msg.header.frame_id = '/map'

        self.global_path_msg = self.calc_dijkstra_path_node(self.start_node, self.end_node)

        rate = rospy.Rate(10) # 10hz
        while not rospy.is_shutdown():
            # (11) dijkstra ì´ìš©í•´ ë§Œë“  Global Path ì •ë³´ Publish
            
            # dijkstra ì´ìš©í•´ ë§Œë“  Global Path ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
            self.global_path_pub.publish(self.global_path_msg)
            rate.sleep()

    def calc_dijkstra_path_node(self, start_node, end_node):

        result, path = self.global_planner.find_shortest_path(start_node, end_node)

        #TODO: (10) dijkstra ê²½ë¡œ ë°ì´í„°ë¥¼ ROS Path ë©”ì„¸ì§€ í˜•ì‹ì— ë§ì¶° ì •ì˜
        out_path = Path()
        out_path.header.frame_id = '/map'
        
        # dijkstra ê²½ë¡œ ë°ì´í„° ì¤‘ Point ì •ë³´ë¥¼ ì´ìš©í•˜ì—¬ Path ë°ì´í„°ë¥¼ ë§Œë“¤ì–´ ì¤ë‹ˆë‹¤.

        for point in path['point_path']:
            pose = PoseStamped()
            pose.header.frame_id = '/map'
            pose.pose.position.x = point[0]
            pose.pose.position.y = point[1]
            pose.pose.position.z = point[2]
            out_path.poses.append(pose)

        return out_path

class Dijkstra:
    def __init__(self, nodes, links):
        self.nodes = nodes
        self.links = links
        #(3) weight ê°’ ê³„ì‚°
        self.weight = self.get_weight_matrix()
        self.lane_change_link_idx = []

    def get_weight_matrix(self):
        # (3) weight ê°’ ê³„ì‚°
        
        # weight ê°’ ê³„ì‚°ì€ ê° Node ì—ì„œ ì¸ì ‘ í•œ ë‹¤ë¥¸ Node ê¹Œì§€ì˜ ë¹„ìš©ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
        # ê³„ì‚°ëœ weight ê°’ ì€ ê° ë…¸ë“œê°„ ì´ë™ì‹œ ë°œìƒí•˜ëŠ” ë¹„ìš©(ê±°ë¦¬)ì„ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì—
        # Dijkstra íƒìƒ‰ì—ì„œ ì¤‘ìš”í•˜ê²Œ ì‚¬ìš© ë©ë‹ˆë‹¤.
        # weight ê°’ì€ ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ì‚¬ìš© í•©ë‹ˆë‹¤.
        # ì´ì¤‘ ì¤‘ì²©ëœ ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ì‚¬ìš©í•˜ë©° 
        # Key ê°’ìœ¼ë¡œ Nodeì˜ Idx Value ê°’ìœ¼ë¡œ ë‹¤ë¥¸ ë…¸ë“œ ê¹Œì§€ì˜ ë¹„ìš©ì„ ê°€ì§€ë„ë¡ í•©ë‹ˆë‹¤.
        # ì•„ë˜ ì½”ë“œ ì¤‘ self.find_shortest_link_leading_to_node ë¥¼ ì™„ì„±í•˜ì—¬ 
        # Dijkstra ì•Œê³ ë¦¬ì¦˜ ê³„ì‚°ì„ ìœ„í•œ Nodeì™€ Node ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

        
        # ì´ˆê¸° ì„¤ì •
        weight = dict() 
        for from_node_id, from_node in self.nodes.items():
            # í˜„ì¬ ë…¸ë“œì—ì„œ ë‹¤ë¥¸ ë…¸ë“œë¡œ ì§„í–‰í•˜ëŠ” ëª¨ë“  weight
            weight_from_this_node = dict()
            for to_node_id, to_node in self.nodes.items():
                weight_from_this_node[to_node_id] = float('inf')
            # ì „ì²´ weight matrixì— ì¶”ê°€
            weight[from_node_id] = weight_from_this_node

        for from_node_id, from_node in self.nodes.items():
            # í˜„ì¬ ë…¸ë“œì—ì„œ í˜„ì¬ ë…¸ë“œë¡œëŠ” cost = 0
            weight[from_node_id][from_node_id] = 0

            for to_node in from_node.get_to_nodes():
                # í˜„ì¬ ë…¸ë“œì—ì„œ to_nodeë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ë§í¬ë¥¼ ì°¾ê³ , ê·¸ ì¤‘ì—ì„œ ê°€ì¥ ë¹ ë¥¸ ë§í¬ë¥¼ ì°¾ì•„ì¤€ë‹¤
                shortest_link, min_cost = self.find_shortest_link_leading_to_node(from_node,to_node)
                weight[from_node_id][to_node.idx] = min_cost           

        return weight

    def find_shortest_link_leading_to_node(self, from_node,to_node):
        # í˜„ì¬ ë…¸ë“œì—ì„œ to_nodeë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ë§í¬ë¥¼ ì°¾ê³ , ê·¸ ì¤‘ì—ì„œ ê°€ì¥ ë¹ ë¥¸ ë§í¬ë¥¼ ì°¾ì•„ì¤€ë‹¤
        # (3) weight ê°’ ê³„ì‚°
        
        # ìµœë‹¨ê±°ë¦¬ Link ì¸ shortest_link ë³€ìˆ˜ì™€
        # shortest_link ì˜ min_cost ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.

        shortest_link = None
        min_cost = float('inf')
        for link_id in from_node.to_links:
            link = link_id
            if link.to_node.idx == to_node.idx:
                if link.cost < min_cost:
                    shortest_link = link
                    min_cost = link.cost
        return shortest_link, min_cost

        
    def find_nearest_node_idx(self, distance, s):        
        idx_list = self.nodes.keys()
        min_value = float('inf')
        min_idx = idx_list[-1]

        for idx in idx_list:
            if distance[idx] < min_value and s[idx] == False :
                min_value = distance[idx]
                min_idx = idx
        return min_idx

    def find_shortest_path(self, start_node_idx, end_node_idx): 
        # (4) Dijkstra Path ì´ˆê¸°í™” ë¡œì§
        # s ì´ˆê¸°í™”         >> s = [False] * len(self.nodes)
        # from_node ì´ˆê¸°í™” >> from_node = [start_node_idx] * len(self.nodes)
        
        # Dijkstra ê²½ë¡œ íƒìƒ‰ì„ ìœ„í•œ ì´ˆê¸°í™” ë¡œì§ ì…ë‹ˆë‹¤.
        # ë³€ìˆ˜ sì™€ from_node ëŠ” ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ í¬ê¸°ë¥¼ MGeoì˜ Node ì˜ ê°œìˆ˜ë¡œ ì„¤ì •í•©ë‹ˆë‹¤. 
        # Dijkstra ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ íƒìƒ‰ í•œ Node ëŠ” ë³€ìˆ˜ s ì— True ë¡œ íƒìƒ‰í•˜ì§€ ì•Šì€ ë³€ìˆ˜ëŠ” False ë¡œ í•©ë‹ˆë‹¤.
        # from_node ì˜ Key ê°’ì€ Node ì˜ Idxë¡œ
        # from_node ì˜ Value ê°’ì€ Key ê°’ì˜ Node Idx ì—ì„œ ê°€ì¥ ë¹„ìš©ì´ ì‘ì€(ê°€ì¥ ê°€ê¹Œìš´) Node Idxë¡œ í•©ë‹ˆë‹¤.
        # from_node í†µí•´ ê° Node ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ Node ì°¾ê³ 
        # ì´ë¥¼ ì—°ê²°í•´ ì‹œì‘ ë…¸ë“œë¶€í„° ë„ì°© ë…¸ë“œ ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤. 

        
        s = dict()
        from_node = dict() 
        for node_id in self.nodes.keys():
            s[node_id] = False
            from_node[node_id] = start_node_idx

        s[start_node_idx] = True
        distance =copy.deepcopy(self.weight[start_node_idx])

        # (5) Dijkstra í•µì‹¬ ì½”ë“œ
        for i in range(len(self.nodes.keys()) - 1):
            selected_node_idx = self.find_nearest_node_idx(distance, s)
            s[selected_node_idx] = True            
            for j, to_node_idx in enumerate(self.nodes.keys()):
                if s[to_node_idx] == False:
                    distance_candidate = distance[selected_node_idx] + self.weight[selected_node_idx][to_node_idx]
                    if distance_candidate < distance[to_node_idx]:
                        distance[to_node_idx] = distance_candidate
                        from_node[to_node_idx] = selected_node_idx

        #(6) node path ìƒì„±
        tracking_idx = end_node_idx
        node_path = [end_node_idx]
        
        while start_node_idx != tracking_idx:
            tracking_idx = from_node[tracking_idx]
            node_path.append(tracking_idx)     

        node_path.reverse()

        #(7) link path ìƒì„±
        link_path = []
        for i in range(len(node_path) - 1):
            from_node_idx = node_path[i]
            to_node_idx = node_path[i + 1]

            from_node = self.nodes[from_node_idx]
            to_node = self.nodes[to_node_idx]

            shortest_link, min_cost = self.find_shortest_link_leading_to_node(from_node,to_node)
            link_path.append(shortest_link.idx)

        # (8) Result íŒë³„
        if len(link_path) == 0:
            return False, {'node_path': node_path, 'link_path':link_path, 'point_path':[]}

        # (9) point path ìƒì„±
        point_path = []        
        for link_id in link_path:
            link = self.links[link_id]
            for point in link.points:
                point_path.append([point[0], point[1], 0])

        return True, {'node_path': node_path, 'link_path':link_path, 'point_path':point_path}

if __name__ == '__main__':
    
    dijkstra_path_pub = dijkstra_path_pub()
```

<br>

#### 4-3) ì‹œê°í™”

```python
$ roslaunch ssafy_2 dijkstra_path_pub.launch
```

![Dijkstra](../images/ëª…ì„¸ì„œ(2)_images/Dijkstra-1.png)

ì „ì—­ê²½ë¡œ(Global Path)ê°€ ìµœë‹¨ ê²½ë¡œë¡œ ì¶œë ¥ ë˜ì—ˆìŒì„ í™•ì¸ ê°€ëŠ¥


---

## 5. mgeo_dijsktra_path_2.py

#### 5-1) ì½”ë“œ

```
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
import sys
import os
import copy
import numpy as np
import json

from math import cos,sin,sqrt,pow,atan2,pi
from geometry_msgs.msg import Point32,PoseStamped, PoseWithCovarianceStamped
from nav_msgs.msg import Odometry,Path

current_path = os.path.dirname(os.path.realpath(__file__))
sys.path.append(current_path)

from lib.mgeo.class_defs import *

# mgeo_dijkstra_path_1 ì€ Mgeo ë°ì´í„°ë¥¼ ì´ìš©í•˜ì—¬ ì‹œì‘ Node ì™€ ëª©ì ì§€ Node ë¥¼ ì§€ì •í•˜ì—¬ Dijkstra ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ëŠ” ì˜ˆì œ ì…ë‹ˆë‹¤.
# ì‚¬ìš©ìê°€ ì§ì ‘ ì§€ì •í•œ ì‹œì‘ Node ì™€ ëª©ì ì§€ Node ì‚¬ì´ ìµœë‹¨ ê²½ë¡œ ê³„ì‚°í•˜ì—¬ global Path(ì „ì—­ê²½ë¡œ) ë¥¼ ìƒì„± í•©ë‹ˆë‹¤.
# ì‹œì‘ Node ì™€ ëª©ì ì§€ Node ëŠ” Rviz ì˜ goal pose / initial pose ë‘ ê¸°ëŠ¥ì„ ì´ìš©í•˜ì—¬ ì •ì˜í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸
# 2. ì‹œì‘ Node ì™€ ì¢…ë£Œ Node ì •ì˜
# 3. weight ê°’ ê³„ì‚°
# 4. Dijkstra Path ì´ˆê¸°í™” ë¡œì§
# 5. Dijkstra í•µì‹¬ ì½”ë“œ
# 6. node path ìƒì„±
# 7. link path ìƒì„±
# 8. Result íŒë³„
# 9. point path ìƒì„±
# 10. dijkstra ê²½ë¡œ ë°ì´í„°ë¥¼ ROS Path ë©”ì„¸ì§€ í˜•ì‹ì— ë§ì¶° ì •ì˜
# 11. dijkstra ì´ìš©í•´ ë§Œë“  Global Path ì •ë³´ Publish

# (0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹

# dijkstra ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ë˜í”„ êµ¬ì¡°ì—ì„œ ë…¸ë“œ ê°„ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ ì…ë‹ˆë‹¤.
# ì‹œì‘ ë…¸ë“œë¶€í„° ë‹¤ë¥¸ ëª¨ë“  ë…¸ë“œê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤.
# ë‹¤ì–‘í•œ ì„œë¹„ìŠ¤ì—ì„œ ì‹¤ì œë¡œ ì‚¬ìš© ë˜ë©° ì¸ê³µ ìœ„ì„±ì—ë„ ì‚¬ìš©ë˜ëŠ” ë°©ì‹ ì…ë‹ˆë‹¤.
# ì „ì²´ ë™ì‘ ê³¼ì •ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
#
# 1. ì‹œì‘ ë…¸ë“œ ì§€ì •
# 2. ì‹œì‘ ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ë¥¸ ë…¸ë“œì™€ì˜ ë¹„ìš©ì„ ì €ì¥(ê²½ë¡œ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” ë¹„ìš©ì´ë€ ê²½ë¡œì˜ í¬ê¸°ë¥¼ ì˜ë¯¸)
# 3. ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œë“¤ ì¤‘ ê°€ì¥ ì ì€ ë¹„ìš©ì˜ ë…¸ë“œë¥¼ ë°©ë¬¸
# 4. ë°©ë¬¸í•œ ë…¸ë“œì™€ ì¸ì ‘í•œ ë…¸ë“œë“¤ì„ ì¡°ì‚¬í•´ì„œ ìƒˆë¡œ ì¡°ì‚¬ëœ ìµœë‹¨ ê±°ë¦¬ê°€ ê¸°ì¡´ ë°œê²¬ëœ ìµœë‹¨ê±°ë¦¬ ë³´ë‹¤ ì‘ìœ¼ë©´ ì •ë³´ë¥¼ ê°±ì‹ 
#   [   ìƒˆë¡œ ì¡°ì‚¬ëœ ìµœë‹¨ ê±°ë¦¬ : ì‹œì‘ ë…¸ë“œì—ì„œ ë°©ë¬¸ ë…¸ë“œ ê¹Œì§€ì˜ ê±°ë¦¬ ë¹„ìš© + ë°©ë¬¸ ë…¸ë“œì—ì„œ ì¸ì ‘ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ ë¹„ìš©    ]
#   [   ê¸°ì¡´ ë°œê²¬ëœ ìµœë‹¨ ê±°ë¦¬ : ì‹œì‘ ë…¸ë“œì—ì„œ ì¸ì ‘ ë…¸ë“œê¹Œì§€ì˜ ê±°ë¦¬ ë¹„ìš©                                       ]
# 5. 3 ~ 4 ê³¼ì •ì„ ë°˜ë³µ 
# 


class dijkstra_path_pub :
    def __init__(self):
        rospy.init_node('dijkstra_path_pub', anonymous=True)

        self.global_path_pub = rospy.Publisher('/global_path',Path, queue_size = 1)

        rospy.Subscriber('/move_base_simple/goal', PoseStamped, self.goal_callback)
        rospy.Subscriber('/initialpose', PoseWithCovarianceStamped, self.init_callback)

        # (1) Mgeo data ì½ì–´ì˜¨ í›„ ë°ì´í„° í™•ì¸
        load_path = os.path.normpath(os.path.join(current_path, 'lib/mgeo_data/R_KR_PG_K-City'))
        mgeo_planner_map = MGeo.create_instance_from_json(load_path)

        node_set = mgeo_planner_map.node_set
        link_set = mgeo_planner_map.link_set

        self.nodes=node_set.nodes
        self.links=link_set.lines

        self.global_planner=Dijkstra(self.nodes,self.links)

        self.is_goal_pose = False
        self.is_init_pose = False

        while True:
            if self.is_goal_pose == True and self.is_init_pose == True:
                break
            else:
                rospy.loginfo('Waiting goal pose data')
                rospy.loginfo('Waiting init pose data')


        self.global_path_msg = Path()
        self.global_path_msg.header.frame_id = '/map'

        self.global_path_msg = self.calc_dijkstra_path_node(self.start_node, self.end_node)

        rate = rospy.Rate(10) # 10hz
        while not rospy.is_shutdown(): # ë£¨í”„ ì‹œì‘
            #(11) dijkstra ì´ìš©í•´ ë§Œë“  Global Path ì •ë³´ Publish
            
            # Global Path ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
            self.global_path_pub.publish(self.global_path_msg)
            debugging = -1
            # dijkstra ì´ìš©í•´ ë§Œë“  Global Path ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
            # self.global_path_pub.publish(self.global_path_msg)
            self.is_goal_pose = False
            self.is_init_pose = False
            
            rate.sleep()

        # ë‹¤ì‹œ ì‹œì‘ì ê³¼ ëì ì„ ë°›ì„ ë•Œê¹Œì§€ ëŒ€ê¸°
        # self.is_goal_pose = False
        # self.is_init_pose = False
    
    def init_callback(self,msg):
        # (2) ì‹œì‘ Node ì™€ ì¢…ë£Œ Node ì •ì˜
        # ì‹œì‘ Node ëŠ” Rviz ê¸°ëŠ¥ì„ ì´ìš©í•´ ì§€ì •í•œ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œì´ ìˆëŠ” Node ë¡œ í•œë‹¤.
        
        # Rviz ì˜ 2D Pose Estimate ê¸°ëŠ¥ì„ ì´ìš©í•´ ì‹œì‘ Nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        # Rviz ì°½ì—ì„œ 2D Pose Estimate ê¸°ëŠ¥ í´ë¦­ í›„ ë§ˆìš°ìŠ¤ ì¢Œ í´ë¦­ì„ í†µí•´ ì›í•˜ëŠ” ìœ„ì¹˜ë¥¼ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        # ì¶œë°œ ìœ„ì¹˜ë¥¼ 2D Pose Estimate ì§€ì • í•˜ë©´ Rviz ì—ì„œ
        # PoseWithCovarianceStamped í˜•ì‹ì˜ ROS ë©”ì„¸ì§€ë¥¼ Publish í•©ë‹ˆë‹¤.
        # í•´ë‹¹ í˜•ì‹ì˜ ë©”ì„¸ì§€ë¥¼ Subscribe í•´ì„œ  2D Pose Estimate ë¡œ ì§€ì •í•œ ìœ„ì¹˜ì™€ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ íƒìƒ‰í•˜ëŠ” í•©ë‹ˆë‹¤.
        # ê°€ì¥ ê°€ê¹Œìš´ Node ê°€ íƒìƒ‰ ëœë‹¤ë©´ ì´ë¥¼ "self.start_node" ë³€ìˆ˜ì— í•´ë‹¹ Node Idx ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        x = msg.pose.pose.position.x
        y = msg.pose.pose.position.y

        # ì‹œì‘ ë…¸ë“œì™€ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œ ì°¾ê¸°
        min_dist = float('inf')
        start_node_idx = None
        for node in self.nodes.values():
            dist = sqrt(pow(x - node.point[0], 2) + pow(y - node.point[1], 2))
            if dist < min_dist:
                min_dist = dist
                start_node_idx = node.idx

        self.start_node = start_node_idx
        self.is_init_pose = True

        debugging = -1

    def goal_callback(self,msg):
        #(2) ì‹œì‘ Node ì™€ ì¢…ë£Œ Node ì •ì˜
        # ì¢…ë£Œ Node ëŠ” Rviz ê¸°ëŠ¥ì„ ì´ìš©í•´ ì§€ì •í•œ ìœ„ì¹˜ì—ì„œ ê°€ì¥ ê°€ê¹Œì´ ìˆëŠ” Node ë¡œ í•œë‹¤.
        
        # Rviz ì˜ 2D Nav Goal ê¸°ëŠ¥ì„ ì´ìš©í•´ ë„ì°© Nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        # Rviz ì°½ì—ì„œ 2D Nav Goal ê¸°ëŠ¥ í´ë¦­ í›„ ë§ˆìš°ìŠ¤ ì¢Œ í´ë¦­ì„ í†µí•´ ì›í•˜ëŠ” ìœ„ì¹˜ë¥¼ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        # ë„ì°© ìœ„ì¹˜ë¥¼ 2D Nav Goal ì§€ì • í•˜ë©´ Rviz ì—ì„œ
        # PoseStamped í˜•ì‹ì˜ ROS ë©”ì„¸ì§€ë¥¼ Publish í•©ë‹ˆë‹¤.
        # í•´ë‹¹ í˜•ì‹ì˜ ë©”ì„¸ì§€ë¥¼ Subscribe í•´ì„œ  2D Nav Goal ë¡œ ì§€ì •í•œ ìœ„ì¹˜ì™€ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ íƒìƒ‰í•˜ëŠ” í•©ë‹ˆë‹¤.
        # ê°€ì¥ ê°€ê¹Œìš´ Node ê°€ íƒìƒ‰ ëœë‹¤ë©´ ì´ë¥¼ "self.start_node" ë³€ìˆ˜ì— í•´ë‹¹ Node Idx ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.

        x = msg.pose.position.x
        y = msg.pose.position.y

        # ì¢…ë£Œ ë…¸ë“œì™€ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œ ì°¾ê¸°
        min_dist = float('inf')
        end_node_idx = None
        for node in self.nodes.values():
            print(node.point[0])
            print(node.point[1])
            dist = sqrt(pow(x - node.point[0], 2) + pow(y - node.point[1], 2))
            if dist < min_dist:
                min_dist = dist
                end_node_idx = node.idx

        self.end_node = end_node_idx
        self.is_goal_pose = True

        debugging = -1

    def calc_dijkstra_path_node(self, start_node, end_node):

        result, path = self.global_planner.find_shortest_path(start_node, end_node)

        #(10) dijkstra ê²½ë¡œ ë°ì´í„°ë¥¼ ROS Path ë©”ì„¸ì§€ í˜•ì‹ì— ë§ì¶° ì •ì˜
        out_path = Path()
        out_path.header.frame_id = '/map'
        
        # dijkstra ê²½ë¡œ ë°ì´í„° ì¤‘ Point ì •ë³´ë¥¼ ì´ìš©í•˜ì—¬ Path ë°ì´í„°ë¥¼ ë§Œë“¤ì–´ ì¤ë‹ˆë‹¤.
        # for node_id in path['node_path']:
        #     # node = self.nodes[node_id]
        #     point = Point32()

        #     for point in path['point_path']:
        #         pose = PoseStamped()
        #         pose.header.frame_id = '/map'
        #         pose.pose.position.x = point[0]
        #         pose.pose.position.y = point[1]
        #         pose.pose.position.z = point[2]
        #         out_path.poses.append(pose)

        point = Point32()

        for point in path['point_path']:
            pose = PoseStamped()
            pose.header.frame_id = '/map'
            pose.pose.position.x = point[0]
            pose.pose.position.y = point[1]
            pose.pose.position.z = point[2]
            out_path.poses.append(pose)

       
        self.global_path_msg = out_path
        

        return out_path

class Dijkstra:
    def __init__(self, nodes, links):
        self.nodes = nodes
        self.links = links
        self.weight = self.get_weight_matrix()
        self.lane_change_link_idx = []

    def get_weight_matrix(self):
        # (3) weight ê°’ ê³„ì‚°
        
        # weight ê°’ ê³„ì‚°ì€ ê° Node ì—ì„œ ì¸ì ‘ í•œ ë‹¤ë¥¸ Node ê¹Œì§€ì˜ ë¹„ìš©ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
        # ê³„ì‚°ëœ weight ê°’ ì€ ê° ë…¸ë“œê°„ ì´ë™ì‹œ ë°œìƒí•˜ëŠ” ë¹„ìš©(ê±°ë¦¬)ì„ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì—
        # Dijkstra íƒìƒ‰ì—ì„œ ì¤‘ìš”í•˜ê²Œ ì‚¬ìš© ë©ë‹ˆë‹¤.
        # weight ê°’ì€ ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ì‚¬ìš© í•©ë‹ˆë‹¤.
        # ì´ì¤‘ ì¤‘ì²©ëœ ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ ì‚¬ìš©í•˜ë©° 
        # Key ê°’ìœ¼ë¡œ Nodeì˜ Idx Value ê°’ìœ¼ë¡œ ë‹¤ë¥¸ ë…¸ë“œ ê¹Œì§€ì˜ ë¹„ìš©ì„ ê°€ì§€ë„ë¡ í•©ë‹ˆë‹¤.
        # ì•„ë˜ ì½”ë“œ ì¤‘ self.find_shortest_link_leading_to_node ë¥¼ ì™„ì„±í•˜ì—¬ 
        # Dijkstra ì•Œê³ ë¦¬ì¦˜ ê³„ì‚°ì„ ìœ„í•œ Nodeì™€ Node ì‚¬ì´ì˜ ìµœë‹¨ ê±°ë¦¬ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

        
        # ì´ˆê¸° ì„¤ì •
        weight = dict() 
        for from_node_id, from_node in self.nodes.items():
            # í˜„ì¬ ë…¸ë“œì—ì„œ ë‹¤ë¥¸ ë…¸ë“œë¡œ ì§„í–‰í•˜ëŠ” ëª¨ë“  weight
            weight_from_this_node = dict()
            for to_node_id, to_node in self.nodes.items():
                weight_from_this_node[to_node_id] = float('inf')
            # ì „ì²´ weight matrixì— ì¶”ê°€
            weight[from_node_id] = weight_from_this_node

        for from_node_id, from_node in self.nodes.items():
            # í˜„ì¬ ë…¸ë“œì—ì„œ í˜„ì¬ ë…¸ë“œë¡œëŠ” cost = 0
            weight[from_node_id][from_node_id] = 0

            for to_node in from_node.get_to_nodes():
                # í˜„ì¬ ë…¸ë“œì—ì„œ to_nodeë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ë§í¬ë¥¼ ì°¾ê³ , ê·¸ ì¤‘ì—ì„œ ê°€ì¥ ë¹ ë¥¸ ë§í¬ë¥¼ ì°¾ì•„ì¤€ë‹¤
                shortest_link, min_cost = self.find_shortest_link_leading_to_node(from_node,to_node)
                weight[from_node_id][to_node.idx] = min_cost           

        return weight

    def find_shortest_link_leading_to_node(self, from_node,to_node):
        """í˜„ì¬ ë…¸ë“œì—ì„œ to_nodeë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ë§í¬ë¥¼ ì°¾ê³ , ê·¸ ì¤‘ì—ì„œ ê°€ì¥ ë¹ ë¥¸ ë§í¬ë¥¼ ì°¾ì•„ì¤€ë‹¤"""
        # (3) weight ê°’ ê³„ì‚°
        
        # ìµœë‹¨ê±°ë¦¬ Link ì¸ shortest_link ë³€ìˆ˜ì™€
        # shortest_link ì˜ min_cost ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.

        shortest_link = None
        min_cost = float('inf')
        for link_id in from_node.to_links:
            link = link_id
            if link.to_node.idx == to_node.idx:
                if link.cost < min_cost:
                    shortest_link = link
                    min_cost = link.cost
        
        return shortest_link, min_cost
        
    def find_nearest_node_idx(self, distance, s):        
        idx_list = self.nodes.keys()
        min_value = float('inf')
        min_idx = idx_list[-1]

        for idx in idx_list:
            if distance[idx] < min_value and s[idx] == False :
                min_value = distance[idx]
                min_idx = idx
        return min_idx

    def find_shortest_path(self, start_node_idx, end_node_idx): 
        # (4) Dijkstra Path ì´ˆê¸°í™” ë¡œì§
        # s ì´ˆê¸°í™”         >> s = [False] * len(self.nodes)
        # from_node ì´ˆê¸°í™” >> from_node = [start_node_idx] * len(self.nodes)
        
        # Dijkstra ê²½ë¡œ íƒìƒ‰ì„ ìœ„í•œ ì´ˆê¸°í™” ë¡œì§ ì…ë‹ˆë‹¤.
        # ë³€ìˆ˜ sì™€ from_node ëŠ” ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¡œ í¬ê¸°ë¥¼ MGeoì˜ Node ì˜ ê°œìˆ˜ë¡œ ì„¤ì •í•©ë‹ˆë‹¤. 
        # Dijkstra ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ íƒìƒ‰ í•œ Node ëŠ” ë³€ìˆ˜ s ì— True ë¡œ íƒìƒ‰í•˜ì§€ ì•Šì€ ë³€ìˆ˜ëŠ” False ë¡œ í•©ë‹ˆë‹¤.
        # from_node ì˜ Key ê°’ì€ Node ì˜ Idxë¡œ
        # from_node ì˜ Value ê°’ì€ Key ê°’ì˜ Node Idx ì—ì„œ ê°€ì¥ ë¹„ìš©ì´ ì‘ì€(ê°€ì¥ ê°€ê¹Œìš´) Node Idxë¡œ í•©ë‹ˆë‹¤.
        # from_node í†µí•´ ê° Node ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ Node ì°¾ê³ 
        # ì´ë¥¼ ì—°ê²°í•´ ì‹œì‘ ë…¸ë“œë¶€í„° ë„ì°© ë…¸ë“œ ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ íƒìƒ‰í•©ë‹ˆë‹¤. 

        
        s = dict()
        from_node = dict() 
        for node_id in self.nodes.keys():
            s[node_id] = False
            from_node[node_id] = start_node_idx

        s[start_node_idx] = True
        distance =copy.deepcopy(self.weight[start_node_idx])

        #: (5) Dijkstra í•µì‹¬ ì½”ë“œ
        for i in range(len(self.nodes.keys()) - 1):
            selected_node_idx = self.find_nearest_node_idx(distance, s)
            s[selected_node_idx] = True            
            for j, to_node_idx in enumerate(self.nodes.keys()):
                if s[to_node_idx] == False:
                    distance_candidate = distance[selected_node_idx] + self.weight[selected_node_idx][to_node_idx]
                    if distance_candidate < distance[to_node_idx]:
                        distance[to_node_idx] = distance_candidate
                        from_node[to_node_idx] = selected_node_idx

        #: (6) node path ìƒì„±
        tracking_idx = end_node_idx
        node_path = [end_node_idx]
        
        while start_node_idx != tracking_idx:
            tracking_idx = from_node[tracking_idx]
            node_path.append(tracking_idx)     

        node_path.reverse()

        #: (7) link path ìƒì„±
        link_path = []
        for i in range(len(node_path) - 1):
            from_node_idx = node_path[i]
            to_node_idx = node_path[i + 1]

            from_node = self.nodes[from_node_idx]
            to_node = self.nodes[to_node_idx]

            shortest_link, min_cost = self.find_shortest_link_leading_to_node(from_node,to_node)
            #ë§Œì•½ì— ê²½ë¡œê°€ ì—†ì–´ì„œ shortest_linkê°€ Noneì´ë¼ë©´ ì—ëŸ¬!
            link_path.append(shortest_link.idx)

        #: (8) Result íŒë³„
        if len(link_path) == 0:
            return False, {'node_path': node_path, 'link_path':link_path, 'point_path':[]}

        #: (9) point path ìƒì„±
        point_path = []        
        for link_id in link_path:
            link = self.links[link_id]
            for point in link.points:
                point_path.append([point[0], point[1], 0])

        return True, {'node_path': node_path, 'link_path':link_path, 'point_path':point_path}

if __name__ == '__main__':
    
    dijkstra_path_pub = dijkstra_path_pub()
```


<br>

#### 5-2) dijkstra_path_pub.launch
```
<launch>
    <node pkg="ssafy_2" type="mgeo_pub.py" name="mgeo_pub"  />
    <node pkg="ssafy_2" type="gpsimu_parser.py" name="gpsimu_parser" />
    <!-- <node pkg="ssafy_2" type="mgeo_dijkstra_path_1.py" name="mgeo_dijkstra_path"  /> -->
    <node pkg="ssafy_2" type="mgeo_dijkstra_path_2.py" name="mgeo_dijkstra_path"  />
    <node pkg="ssafy_2" type="local_path_pub.py" name="local_path_pub" />
    <node pkg="ssafy_2" type="tf_pub.py" name="tf"  />

    <node pkg="rviz" type="rviz" name="rviz" args="-d $(find ssafy_2)/rviz/kcity_rviz.rviz" />
</launch>
```

<br>

#### 5-3) ì‹œê°í™”
```
$ roslaunch ssafy_2 dijkstra_path_pub.launch
```
![Dijkstra-2](../images/ëª…ì„¸ì„œ(2)_images/Dijkstra-2.png)
ì§ì ‘ ì„¤ì •í•œ ì‹œì‘ì  ë° ì¢…ë£Œì  ê°„ì˜ ìµœë‹¨ ê±°ë¦¬ê°€ ë‚˜íƒ€ë‚œë‹¤.