# ëª…ì„¸ì„œ 2 
#### ìŠ¤ì¼ˆë ˆí†¤ í”„ë¡œì íŠ¸ (3)
#### ì œì–´ ê´€ë ¨ ì‹¤ìŠµ

<br>

#### ëª©ì°¨
1. [pure_persuit.py](#1-pure_persuitpy)
    - [ì½”ë“œ](#1-1-ì½”ë“œ)
    - [ê²°ê³¼](#1-2-ê²°ê³¼)

2. [pid_control](#2-pid_controlpy)
    - [ì½”ë“œ](#2-1-ì½”ë“œ)
    - [ê²°ê³¼](#2-2-ê²°ê³¼)

3. [velocity_planning.py](#3-velocity_planningpy)
    - [ì½”ë“œ](#3-1-ì½”ë“œ)
    - [ê²°ê³¼](#3-2-ê²°ê³¼)

4. [advanced_purepursuit.py](#4-advanced_purepursuitpy)
    - [To Do](#4-1-to-do)
    - [ì½”ë“œ](#4-2-ì½”ë“œ)
    - [Flow Chart](#4-3-flow-chart)



<br>

---

## 1. pure_persuit.py

#### 1-1) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow,atan2
from geometry_msgs.msg import Point,PoseWithCovarianceStamped
from nav_msgs.msg import Odometry,Path
from morai_msgs.msg import CtrlCmd
import numpy as np
import tf

# pure_pursuit ì€ ì°¨ëŸ‰ì˜ ì°¨ëŸ‰ì˜ íš¡ ë°©í–¥ ì œì–´ ì˜ˆì œì…ë‹ˆë‹¤.
# ì°¨ëŸ‰ì´ ì£¼í–‰í•  Local Path (ì§€ì—­ê²½ë¡œ) ì™€ ì°¨ëŸ‰ì˜ ìƒíƒœ ì •ë³´ Odometry ë¥¼ ë°›ì•„ ì°¨ëŸ‰ì„ ì œì–´ í•©ë‹ˆë‹¤.
# ì°¨ëŸ‰ì˜ ì œì–´ ì…ë ¥ì€ CtrlCmd ë©”ì„¸ì§€ë¥¼ ì´ìš© í•˜ë©° ì¢…ë°©í–¥ ì œì–´ ì…ë ¥ì€ longlCmdType 2(Velocity control) ì´ìš©í•˜ì—¬ ë“±ì† ìš´ë™ í•˜ë„ë¡ í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. subscriber, publisher ì„ ì–¸
# 2. ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
# 3. Steering ê°ë„ ê³„ì‚°
# 4. ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish

#(0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹

# Pure Pursuit ì€ ì°¨ëŸ‰ì˜ Kinematic Model Based ê²½ë¡œ ì¶”ì¢… ì•Œê³ ë¦¬ì¦˜ ì…ë‹ˆë‹¤.
# í˜„ì¬ ì°¨ëŸ‰ì˜ Heading ê°ë„ì™€ ì‹¤ì œ Path ì˜ ê°ë„ ì˜¤ì°¨ë¥¼ ê³„ì‚°í•˜ì—¬ ì°¨ëŸ‰ì˜ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
# ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ë¼ëŠ” ë³€ìˆ˜ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.
# ì „ë°©ì£¼ì‹œê±°ë¦¬ëŠ” Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì—ì„œ ê¸°ì¤€ìœ¼ë¡œ í•˜ëŠ” ì¶”ì¢… ê±°ë¦¬ë¡œ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•˜ëŠ”ë° ì´ìš© í•©ë‹ˆë‹¤.
# ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance)ëŠ” í•´ë‹¹ ì˜ˆì œì—ì„œ "self.lfd" ë¼ëŠ” ë³€ìˆ˜ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
# ì§ì ‘ "self.lfd" ë³€ìˆ˜ì˜ ê°’ì— ì ì ˆí•œ ê°’ì„ ë„£ì–´ ì œì–´ ì•Œê³ ë¦¬ì¦˜ì˜ ì„±ëŠ¥ì„ ì˜¬ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
# ì•„ë˜ ì •ì˜ ëœ ë³€ìˆ˜ ì¤‘ "self.vehicle_length" ì™€ "self.lfd" ë¥¼ ë³€ê²½ í•˜ì—¬ì„œ ì§ì ‘ ì œì–´ê¸° ì„±ëŠ¥ì„ íŠœë‹ í•´ë³´ì„¸ìš”.

class pure_pursuit :
    def __init__(self):
        rospy.init_node('pure_pursuit', anonymous=True)

        #(1) subscriber, publisher ì„ ì–¸
        
        # Local Path ì™€ Odometry ë°ì´í„°ë¥¼ ìˆ˜ì‹  í•  Subscriber ë¥¼ ë§Œë“¤ê³  
        # CtrlCmd ë¥¼ ì‹œë®¬ë ˆì´í„°ë¡œ ì „ì†¡ í•  publisher ë³€ìˆ˜ë¥¼ ë§Œë“ ë‹¤.
        # CtrlCmd ì€ 1ì¥ì„ ì°¸ê³  í•œë‹¤.
        rospy.Subscriber("local_path", Path, self.path_callback )
        rospy.Subscriber("/odom", Odometry, self.odom_callback)
        self.ctrl_cmd_pub = rospy.Publisher('ctrl_cmd', CtrlCmd, queue_size=10)

        

        self.ctrl_cmd_msg=CtrlCmd()
        self.ctrl_cmd_msg.longlCmdType=2

        self.is_path=False
        self.is_odom=False

        self.is_look_forward_point=False

        self.forward_point=Point()
        self.current_postion=Point()

        self.vehicle_length = 1
        self.lfd = 1

        rate = rospy.Rate(30) # 30hz

        while not rospy.is_shutdown():

            if self.is_path ==True and self.is_odom==True  :

                steering = self.calc_pure_pursuit()
                if self.is_look_forward_point :
                    self.ctrl_cmd_msg.steering = steering
                    self.ctrl_cmd_msg.velocity = 20.0
                    print(self.ctrl_cmd_msg.steering)
                else : 
                    print("no found forward point")
                    self.ctrl_cmd_msg.steering = 0.0
                    self.ctrl_cmd_msg.velocity = 0.0

                # (4) ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish
                
                # ì œì–´ì…ë ¥ ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.ctrl_cmd_pub.publish(self.ctrl_cmd_msg)

            rate.sleep()

    def path_callback(self,msg):
        self.is_path=True
        self.path=msg  

    def odom_callback(self,msg):
        self.is_odom=True
        odom_quaternion=(msg.pose.pose.orientation.x,msg.pose.pose.orientation.y,msg.pose.pose.orientation.z,msg.pose.pose.orientation.w)
        _,_,self.vehicle_yaw=tf.transformations.euler_from_quaternion(odom_quaternion)
        self.current_postion.x=msg.pose.pose.position.x
        self.current_postion.y=msg.pose.pose.position.y

    def calc_pure_pursuit(self,):                
        vehicle_position=self.current_postion
        self.is_look_forward_point= False

        translation = [vehicle_position.x, vehicle_position.y]

        # (2) ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
        
        # Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰ í•˜ê¸° ìœ„í•´ì„œ ì°¨ëŸ‰ ê¸°ì¤€ì˜ ì¢Œí‘œê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ í˜„ì¬ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œê³„ë¡œ ì¢Œí‘œ ë³€í™˜ì´ í•„ìš”í•©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì‘ì„±í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë³€í™˜ í›„ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì´ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•˜ê²Œ ë©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì´ìš©í•´ Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë°”ê¾¸ëŠ” ë°˜ë³µ ë¬¸ì„ ì‘ì„± í•œ ë’¤
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ê³„ì‚°í•˜ëŠ” ë¡œì§ì„ ì‘ì„± í•˜ì„¸ìš”.

        trans_matrix = np.array([[cos(self.vehicle_yaw),sin(self.vehicle_yaw) * -1,0],
                                [sin(self.vehicle_yaw),cos(self.vehicle_yaw),0],
                                [0,0,1]])

        det_trans_matrix = np.linalg.inv(trans_matrix)

        for num,i in enumerate(self.path.poses) :
            path_point = i.pose.position

            global_path_point = [path_point.x - vehicle_position.x, path_point.y - vehicle_position.y, 1]
            local_path_point = det_trans_matrix.dot(global_path_point)    
            print("g :", global_path_point)
            print("l :", local_path_point)
            if local_path_point[0]>0 :
                dis = sqrt(local_path_point[0]**2 + local_path_point[1]**2)
                if dis >= self.lfd :
                    self.forward_point = local_path_point
                    self.is_look_forward_point = True
                    break
        
        # (3) Steering ê°ë„ ê³„ì‚°
        
        # ì œì–´ ì…ë ¥ì„ ìœ„í•œ Steering ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # theta ëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ì¢Œí‘œì˜ ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # Steering ê°ë„ëŠ” Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì˜ ê°ë„ ê³„ì‚° ìˆ˜ì‹ì„ ì ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        theta = atan2(self.forward_point[1], self.forward_point[0])
        steering = atan2( ( 2 * self.vehicle_length * sin(theta)), sqrt(self.forward_point[0]**2 + self.forward_point[1]**2))

        return steering


if __name__ == '__main__':
    try:
        test_track=pure_pursuit()
    except rospy.ROSInterruptException:
        pass

            
```

<br>

#### 1-2) ê²°ê³¼

<aside>
ğŸ’¡ ì¡°í–¥ê°ì„ ì œì–´í•˜ê¸´ í•˜ì§€ë§Œ ì•„ì§ ë¯¸ì™„ì„±

</aside>


<br>

---


## 2. pid_control.py

#### 2-1) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow,atan2
from geometry_msgs.msg import Point,PoseWithCovarianceStamped
from nav_msgs.msg import Odometry,Path
from morai_msgs.msg import CtrlCmd,EgoVehicleStatus
import numpy as np
import tf
from tf.transformations import euler_from_quaternion,quaternion_from_euler

# pid_contorl ì€ ì°¨ëŸ‰ì˜ ì°¨ëŸ‰ì˜ ì¢… íš¡ ë°©í–¥ ì œì–´ ì˜ˆì œì…ë‹ˆë‹¤.
# íš¡ë°©í–¥ ì œì–´ ì…ë ¥ì€ ì£¼í–‰í•  Local Path (ì§€ì—­ê²½ë¡œ) ì™€ ì°¨ëŸ‰ì˜ ìƒíƒœ ì •ë³´ Odometry ë¥¼ ë°›ì•„ ì°¨ëŸ‰ì„ ì œì–´ í•©ë‹ˆë‹¤.
# ì¢…ë°©í–¥ ì œì–´ ì…ë ¥ì€ ëª©í‘œ ì†ë„ë¥¼ ì§€ì • í•œë’¤ ëª©í‘œ ì†ë„ì— ë„ë‹¬í•˜ê¸° ìœ„í•œ Throttle control ì„ í•©ë‹ˆë‹¤.
# ì¢…ë°©í–¥ ì œì–´ ì…ë ¥ì€ longlCmdType 1(Throttle control) ì´ìš©í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. subscriber, publisher ì„ ì–¸
# 2. ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
# 3. Steering ê°ë„ ê³„ì‚°
# 4. PID ì œì–´ ìƒì„±
# 5. ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish

# (0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹

# PID ì œì–´ëŠ” ëŒ€í‘œì ì¸ í”¼ë“œë°± ì œì–´ ì´ë¡ ì…ë‹ˆë‹¤.
# í˜„ì¬ ê°’ê³¼ ì›í•˜ëŠ” ëª©í‘œ ê°’ ì°¨ì´ë¥¼ ë¹„êµí•˜ì—¬ ì œì–´í•˜ëŠ” ë°©ì‹ ì…ë‹ˆë‹¤.
# ìˆ˜ì‹ì´ ë§¤ìš° ê°„ë‹¨í•˜ë©°, êµ¬í˜„ ë‚œì´ë„ì— ë¹„í•´ íƒì›”í•œ ì„±ëŠ¥ì„ ê°€ì§‘ë‹ˆë‹¤.
# í•´ë‹¹ ì˜ˆì œì—ì„œëŠ” ì›í•˜ëŠ” ëª©í‘œ ì†ë„ì— ë„ë‹¬í•˜ê¸° ìœ„í•´ í˜„ì¬ ì†ë„ì™€ì˜ ê°’ì„ ë¹„êµí•˜ì—¬ PID ì œì–´ë¥¼ ì§„í–‰í•©ë‹ˆë‹¤.
# Ego_Topic ì„ ì´ìš©í•˜ì—¬ ì°¨ëŸ‰ì˜ í˜„ì¬ ì†ë„ ê°’ì„ ì•Œì•„ëƒ…ë‹ˆë‹¤.
# PID ì œì–´ëŠ” ì›í•˜ëŠ” ê°’ì— ë„ë‹¬í•˜ê¸° ìœ„í•´ P, PI, PD, PID ë“± ì œì–´ ëŒ€ìƒì— ë§ê²Œ ì œì–´ ë°©ì‹ì„ ì„ íƒí•´ì„œ ì‚¬ìš© í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
# P I D ëŠ” ê° ë¹„ë¡€í•­ ì ë¶„í•­ ë¯¸ë¶„í•­ ìœ¼ë¡œ êµ¬ë¶„ ë©ë‹ˆë‹¤.
# P ë¹„ë¡€í•­ì€ ì˜¤ì°¨ ê°’ì— ë”°ë¼ ì¶œë ¥ì´ ë³€ê²½ë©ë‹ˆë‹¤.
# I ì ë¶„í•­ì€ ëˆ„ì ë˜ëŠ” ì˜¤ì°¨ë¥¼ ë³´ì•ˆí•˜ëŠ” ì—­í™œì„ í•©ë‹ˆë‹¤.
# D ë¯¸ë¶„í•­ì€ ì˜¤ì°¨ì˜ ë³€í™”ìœ¨ì— ë°˜ì‘í•˜ì—¬ ì˜¤ì°¨ì˜ ë³€í™”ìœ¨ì´ í¬ë‹¤ë©´ ë¹ ë¥´ê²Œ ì•ˆì •í™” ì‹œí‚¤ëŠ” ì—­í™œì„ í•©ë‹ˆë‹¤.
# PID ê°ê°ì˜ Gain ë³€ìˆ˜ ê°’ì„ ë³€ê²½í•´ ì œì–´ ì„±ëŠ¥ì„ ì˜¬ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
# Gain ë³€ìˆ˜ ê°’ì— ë³€í™”ì— ë”°ë¼ ë³€í™”í•˜ëŠ” ì†ë„ë¥¼ ê´€ì°°í•˜ë©° ì§ì ‘ ì œì–´ê¸°ë¥¼ ë§Œë“¤ì–´ë³´ì„¸ìš”. 


class pure_pursuit :
    def __init__(self):
        rospy.init_node('pure_pursuit', anonymous=True)

        #(1) subscriber, publisher ì„ ì–¸
        
        # Local Path ì™€ Odometry Ego Status ë°ì´í„°ë¥¼ ìˆ˜ì‹  í•  Subscriber ë¥¼ ë§Œë“¤ê³  
        # CtrlCmd ë¥¼ ì‹œë®¬ë ˆì´í„°ë¡œ ì „ì†¡ í•  publisher ë³€ìˆ˜ë¥¼ ë§Œë“ ë‹¤.
        # CtrlCmd ì€ 1ì¥ì„ ì°¸ê³  í•œë‹¤.
        # Ego topic ë°ì´í„°ëŠ” ì°¨ëŸ‰ì˜ í˜„ì¬ ì†ë„ë¥¼ ì•Œê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        rospy.Subscriber("local_path", Path, self.path_callback )
        rospy.Subscriber("/odom", Odometry, self.odom_callback)
        rospy.Subscriber( 'Ego_topic' , EgoVehicleStatus , self.status_callback)
        self.ctrl_cmd_pub = rospy.Publisher('ctrl_cmd', CtrlCmd, queue_size=10)

        

        self.ctrl_cmd_msg=CtrlCmd()
        self.ctrl_cmd_msg.longlCmdType=1

        self.is_path=False
        self.is_odom=False          
        self.is_status=False

        self.is_look_forward_point=False

        self.forward_point=Point()
        self.current_postion=Point()

        self.vehicle_length = 1
        self.lfd = 5
        self.target_vel = 60

        self.pid = pidControl()

        rate = rospy.Rate(30) # 30hz
        while not rospy.is_shutdown():

            if self.is_path == True and self.is_odom == True and self.is_status == True:

                steering = self.calc_pure_pursuit()
                if self.is_look_forward_point :
                    self.ctrl_cmd_msg.steering = steering
                else : 
                    print("no found forward point")
                    self.ctrl_cmd_msg.steering=0.0

                output = self.pid.pid(self.target_vel,self.status_msg.velocity.x*3.6)

                if output > 0.0:
                    self.ctrl_cmd_msg.accel = output
                    self.ctrl_cmd_msg.brake = 0.0
                else:
                    self.ctrl_cmd_msg.accel = 0.0
                    self.ctrl_cmd_msg.brake = -output

                # (5) ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish
                
                # ì œì–´ì…ë ¥ ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.ctrl_cmd_pub.publish(self.ctrl_cmd_msg)
                
                

            rate.sleep()

    def path_callback(self,msg):
        self.is_path=True
        self.path=msg  

    def odom_callback(self,msg):
        self.is_odom=True
        odom_quaternion=(msg.pose.pose.orientation.x,msg.pose.pose.orientation.y,msg.pose.pose.orientation.z,msg.pose.pose.orientation.w)
        _,_,self.vehicle_yaw=euler_from_quaternion(odom_quaternion)
        self.current_postion.x=msg.pose.pose.position.x
        self.current_postion.y=msg.pose.pose.position.y

    def status_callback(self,msg): ## Vehicl Status Subscriber 
        self.is_status=True
        self.status_msg=msg

    def calc_pure_pursuit(self,): 
        vehicle_position=self.current_postion
        self.is_look_forward_point= False

        translation = [vehicle_position.x, vehicle_position.y]

        # (2) ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
        
        # Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰ í•˜ê¸° ìœ„í•´ì„œ ì°¨ëŸ‰ ê¸°ì¤€ì˜ ì¢Œí‘œê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ í˜„ì¬ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œê³„ë¡œ ì¢Œí‘œ ë³€í™˜ì´ í•„ìš”í•©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì‘ì„±í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë³€í™˜ í›„ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì´ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•˜ê²Œ ë©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì´ìš©í•´ Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë°”ê¾¸ëŠ” ë°˜ë³µ ë¬¸ì„ ì‘ì„± í•œ ë’¤
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ê³„ì‚°í•˜ëŠ” ë¡œì§ì„ ì‘ì„± í•˜ì„¸ìš”.

        trans_matrix = np.array([[cos(self.vehicle_yaw),sin(self.vehicle_yaw) * -1,0],
                                [sin(self.vehicle_yaw),cos(self.vehicle_yaw),0],
                                [0,0,1]])

        det_trans_matrix = np.linalg.inv(trans_matrix)

        for num,i in enumerate(self.path.poses) :
            path_point = i.pose.position

            global_path_point = [path_point.x - vehicle_position.x, path_point.y - vehicle_position.y, 1]
            local_path_point = det_trans_matrix.dot(global_path_point)    
            # print("g :", global_path_point)
            # print("l :", local_path_point)
            if local_path_point[0]>0 :
                dis = sqrt(local_path_point[0]**2 + local_path_point[1]**2)
                if dis >= self.lfd :
                    self.forward_point = local_path_point
                    self.is_look_forward_point = True
                    break

        

        # (3) Steering ê°ë„ ê³„ì‚°
        
        # ì œì–´ ì…ë ¥ì„ ìœ„í•œ Steering ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # theta ëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ì¢Œí‘œì˜ ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # Steering ê°ë„ëŠ” Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì˜ ê°ë„ ê³„ì‚° ìˆ˜ì‹ì„ ì ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.

        theta = atan2(self.forward_point[1], self.forward_point[0])
        steering = atan2( ( 2 * self.vehicle_length * sin(theta)), sqrt(self.forward_point[0]**2 + self.forward_point[1]**2))
        
        

        return steering

class pidControl:
    def __init__(self):
        self.p_gain = 0.3
        self.i_gain = 0.00
        self.d_gain = 0.03
        self.prev_error = 0
        self.i_control = 0
        self.controlTime = 0.02

    def pid(self,target_vel, current_vel):
        error = target_vel - current_vel

        # (4) PID ì œì–´ ìƒì„±
        
        # ì¢…ë°©í–¥ ì œì–´ë¥¼ ìœ„í•œ PID ì œì–´ê¸°ëŠ” í˜„ì¬ ì†ë„ì™€ ëª©í‘œ ì†ë„ ê°„ ì°¨ì´ë¥¼ ì¸¡ì •í•˜ì—¬ Accel/Brake ê°’ì„ ê²°ì • í•©ë‹ˆë‹¤.
        # ê° PID ì œì–´ë¥¼ ìœ„í•œ Gain ê°’ì€ "class pidContorl" ì— ì •ì˜ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
        # ê° PID Gain ê°’ì„ ì§ì ‘ íŠœë‹í•˜ê³  ì•„ë˜ ìˆ˜ì‹ì„ ì±„ì›Œ ë„£ì–´ P I D ì œì–´ê¸°ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

        p_control = self.p_gain * error
        self.i_control += self.i_gain * error * self.controlTime
        d_control = self.d_gain * ((error - self.prev_error) / self.controlTime)

        output = p_control + self.i_control + d_control
        self.prev_error = error

        
        print("p_control ", p_control)
        print("i_control ", self.i_control)
        print("d_control ", d_control)

        return output

if __name__ == '__main__':
    try:
        test_track=pure_pursuit()
    except rospy.ROSInterruptException:
        pass

```
<br>

#### 2-2) ê²°ê³¼

ì•„ì§ ë¯¸ì™„ì„±

<br>

---

## 3. velocity_planning.py

#### 3-1) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow,atan2
from geometry_msgs.msg import Point,PoseWithCovarianceStamped
from nav_msgs.msg import Odometry,Path
from morai_msgs.msg import CtrlCmd,EgoVehicleStatus
import numpy as np
import tf
from tf.transformations import euler_from_quaternion,quaternion_from_euler

# velocity_planning ì€ ì°¨ëŸ‰ì˜ ì¢… íš¡ ë°©í–¥ ì œì–´ ì˜ˆì œì…ë‹ˆë‹¤.
# ì°¨ëŸ‰ì˜ ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íšì„ ì„¸ì›Œ ì£¼í–‰ ê²½ë¡œì— ë§ëŠ” ì†ë„ ê³„íšì„ í•  ìˆ˜ ìˆëŠ” ì˜ˆì œ ì…ë‹ˆë‹¤.
# íš¡ë°©í–¥ ì œì–´ ì…ë ¥ì€ ì£¼í–‰í•  Local Path (ì§€ì—­ê²½ë¡œ) ì™€ ì°¨ëŸ‰ì˜ ìƒíƒœ ì •ë³´ Odometry ë¥¼ ë°›ì•„ ì°¨ëŸ‰ì„ ì œì–´ í•©ë‹ˆë‹¤.
# ì¢…ë°©í–¥ ì œì–´ ì…ë ¥ì€ ëª©í‘œ ì†ë„ë¥¼ ì§€ì • í•œë’¤ ëª©í‘œ ì†ë„ì— ë„ë‹¬í•˜ê¸° ìœ„í•œ Throttle control ì„ í•©ë‹ˆë‹¤.
# ì¢…ë°©í–¥ ì œì–´ ì…ë ¥ì€ longlCmdType 1(Throttle control) ì´ìš©í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. subscriber, publisher ì„ ì–¸
# 2. ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
# 3. Steering ê°ë„ ê³„ì‚°
# 4. PID ì œì–´ ìƒì„±
# 5. ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
# 6. ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
# 7. ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish

#(0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹

# ììœ¨ì£¼í–‰ ì°¨ëŸ‰ì€ ì •í•´ì§„ íŠ¹ì • ì†ë„ë¡œë§Œ ì£¼í–‰í•˜ëŠ” ê²ƒì´ ì•„ë‹Œ ë‚´ ì™¸ë¶€ì ì¸ ìš”ì¸ì„ ê³ ë ¤í•˜ì—¬ ì£¼í–‰í•©ë‹ˆë‹¤.
# ì£¼í–‰ í•˜ê¸° ì „ ëŒë°œ ìƒí™©ì´ ì—†ë‹¤ë©´ ë¯¸ë¦¬ ì–´ë–¤ ì†ë„ë¡œ ì£¼í–‰í• ì§€ ì†ë„ ê³„íšì„ ì„¸ìš°ê²Œ ë©ë‹ˆë‹¤.
# ì™¸ë¶€ í™˜ê²½ì ì¸ ìš”ì¸ì¸ ë„ë¡œì˜ ê³¡ë¥ ì„ ì´ìš©í•´ ì°¨ëŸ‰ì˜ ì£¼í–‰ ì†ë„ë¥¼ ê³„ì‚°í•˜ëŠ” ë°©ë²•ì„ í•™ìŠµ í•©ë‹ˆë‹¤.
# ê³¡ë¥ ì´ í° ë„ë¡œì˜ ê²½ìš° ê³¡ë¥ ì— ë§ëŠ” ì†ë„ ê³„íšì´ í•„ìš”í•©ë‹ˆë‹¤.
# ê³¡ë¥ ì´ í° ë„ë¡œì—ì„œ ê³¡ë¥  ìµœëŒ€ ì†ë„ ë³´ë‹¤ í° ì†ë„ë¡œ ì£¼í–‰í•˜ë©´ ì°¨ëŸ‰ì´ ì°¨ì„ ì„ ìœ ì§€ í•˜ë©° ì£¼í–‰ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
# ê·¸ë ‡ê¸° ë•Œë¬¸ì— ë„ë¡œê³¡ë¥ ì— ë§ëŠ” ê°€ì¥ ì ì ˆí•œ ì†ë„ë¡œ ë§ì¶° ì£¼í–‰ í•˜ê¸°ìœ„í•œ ì†ë„ ê³„íšì´ í•„ìš”í•©ë‹ˆë‹¤.
# ê³¡ë¥ ì„ ê³„ì‚°í•˜ëŠ” ë°©ë²•ì—ëŠ” ìµœì†Œ ììŠ¹ë²•ì„ ì´ìš©í•œ(Pseudo Inverse)ê³¡ë¥  ë°˜ê²½ ê³„ì‚° ë°©ì‹, 
# ì›ì˜ ì¢Œí‘œì™€ ë°˜ì§€ë¦„ ê³„ì‚° ìˆ˜ì‹ "(x-a)^2+(y-b)^2=r^2" ì„ í™œìš©í•œ í–‰ë ¬ ê³„ì‚° ë°©ì‹ë“±ì´ ìˆìŠµë‹ˆë‹¤.
# ê³¡ë¥ ì„ ê³„ì‚°í•˜ëŠ” ë°©ì‹ì€ ì—¬ëŸ¬ ê°€ì§€ê°€ ìˆê¸° ë•Œë¬¸ì— ì›í•˜ëŠ” ë°©ì‹ì„ ì‚¬ìš©í•˜ë©´ë©ë‹ˆë‹¤.
# EX)   ì›ì˜ ì¢Œí‘œì™€ ë°˜ì§€ë¦„ ê³„ì‚° ìˆ˜ì‹ì„ ì´ìš©í•œ í–‰ë ¬ì‹
#
#       (x-a)^2+(y-b)^2=r^2
#       x^2 + y^2 - 2ax - 2by + a^2 + b^2 - r^2 = 0
#       c = a^2 + b^2 + r^2
#       x^2 + y^2 - 2ax - 2by + c = 0
#       - 2ax - 2by + c = - x^2 - y^2
#       [-2x1,  -2y1,   1][a]   [ -x1^2 - y1^2  ]
#       [    ,      ,    ][b] = [               ]
#       [-2xn,  -2yn,   1][c]   [ -xn^2 - yn^2  ]
#       {í–‰ë ¬ ê³„ì‚°ì„ ì´ìš© í•œë‹¤}
#

class pure_pursuit :
    def __init__(self):
        rospy.init_node('pure_pursuit', anonymous=True)

        # (1) subscriber, publisher ì„ ì–¸
        
        # Local/Gloabl Path ì™€ Odometry Ego Status ë°ì´í„°ë¥¼ ìˆ˜ì‹  í•  Subscriber ë¥¼ ë§Œë“¤ê³  
        # CtrlCmd ë¥¼ ì‹œë®¬ë ˆì´í„°ë¡œ ì „ì†¡ í•  publisher ë³€ìˆ˜ë¥¼ ë§Œë“ ë‹¤.
        # CtrlCmd ì€ 1ì¥ì„ ì°¸ê³  í•œë‹¤.
        # Ego topic ë°ì´í„°ëŠ” ì°¨ëŸ‰ì˜ í˜„ì¬ ì†ë„ë¥¼ ì•Œê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        # Gloabl Path ë°ì´í„°ëŠ” ê²½ë¡œì˜ ê³¡ë¥ ì„ ì´ìš©í•œ ì†ë„ ê³„íšì„ ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        rospy.Subscriber("/global_path", Path, self.global_path_callback)
        rospy.Subscriber("local_path", Path, self.path_callback )
        rospy.Subscriber("/odom", Odometry, self.odom_callback)
        rospy.Subscriber( 'Ego_topic' , EgoVehicleStatus , self.status_callback)
        self.ctrl_cmd_pub = rospy.Publisher('ctrl_cmd', CtrlCmd, queue_size=10)

        

        self.ctrl_cmd_msg=CtrlCmd()
        self.ctrl_cmd_msg.longlCmdType=1

        self.is_path = False
        self.is_odom = False
        self.is_status = False
        self.is_global_path = False

        self.is_look_forward_point = False

        self.forward_point = Point()
        self.current_postion = Point()

        self.vehicle_length = 1
        self.lfd = 5
        self.target_velocity = 60

        self.pid = pidControl()

        self.vel_planning = velocityPlanning(self.target_velocity/3.6, 0.7)

        while True:
            if self.is_global_path == True:
                self.velocity_list = self.vel_planning.curvedBaseVelocity(self.global_path, 50)
                break
            else:
                rospy.loginfo('Waiting global path data')

        rate = rospy.Rate(30) # 30hz
        while not rospy.is_shutdown():

            if self.is_path == True and self.is_odom == True and self.is_status == True:
                
                self.current_waypoint = self.get_current_waypoint(self.status_msg,self.global_path)
                self.target_velocity = self.velocity_list[self.current_waypoint]*3.6

                steering = self.calc_pure_pursuit()
                if self.is_look_forward_point :
                    self.ctrl_cmd_msg.steering = steering
                else : 
                    print("no found forward point")
                    self.ctrl_cmd_msg.steering = 0.0

                output = self.pid.pid(self.target_velocity,self.status_msg.velocity.x*3.6)

                if output > 0.0:
                    self.ctrl_cmd_msg.accel = output
                    self.ctrl_cmd_msg.brake = 0.0
                else:
                    self.ctrl_cmd_msg.accel = 0.0
                    self.ctrl_cmd_msg.brake = -output

                # (7) ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish
                
                # ì œì–´ì…ë ¥ ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.ctrl_cmd_pub.publish(self.ctrl_cmd_msg)
                
                
                
            rate.sleep()

    def path_callback(self,msg):
        self.is_path=True
        self.path=msg  

    def odom_callback(self,msg):
        self.is_odom=True
        odom_quaternion=(msg.pose.pose.orientation.x,msg.pose.pose.orientation.y,msg.pose.pose.orientation.z,msg.pose.pose.orientation.w)
        _,_,self.vehicle_yaw=euler_from_quaternion(odom_quaternion)
        self.current_postion.x=msg.pose.pose.position.x
        self.current_postion.y=msg.pose.pose.position.y

    def status_callback(self,msg): ## Vehicl Status Subscriber 
        self.is_status=True
        self.status_msg=msg    
        
    def global_path_callback(self,msg):
        self.global_path = msg
        self.is_global_path = True
    
    def get_current_waypoint(self,ego_status,global_path):
        min_dist = float('inf')        
        currnet_waypoint = -1
        for i,pose in enumerate(global_path.poses):
            dx = ego_status.position.x - pose.pose.position.x
            dy = ego_status.position.y - pose.pose.position.y

            dist = sqrt(pow(dx,2)+pow(dy,2))
            if min_dist > dist :
                min_dist = dist
                currnet_waypoint = i
        return currnet_waypoint

    def calc_pure_pursuit(self,):
        vehicle_position=self.current_postion
        self.is_look_forward_point= False

        translation = [vehicle_position.x, vehicle_position.y]

        # (2) ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
        
        # Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰ í•˜ê¸° ìœ„í•´ì„œ ì°¨ëŸ‰ ê¸°ì¤€ì˜ ì¢Œí‘œê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ í˜„ì¬ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œê³„ë¡œ ì¢Œí‘œ ë³€í™˜ì´ í•„ìš”í•©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì‘ì„±í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë³€í™˜ í›„ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì´ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•˜ê²Œ ë©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì´ìš©í•´ Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë°”ê¾¸ëŠ” ë°˜ë³µ ë¬¸ì„ ì‘ì„± í•œ ë’¤
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ê³„ì‚°í•˜ëŠ” ë¡œì§ì„ ì‘ì„± í•˜ì„¸ìš”.

        trans_matrix = np.array([[cos(self.vehicle_yaw),sin(self.vehicle_yaw) * -1,0],
                                [sin(self.vehicle_yaw),cos(self.vehicle_yaw),0],
                                [0,0,1]])

        det_trans_matrix = np.linalg.inv(trans_matrix)

        for num,i in enumerate(self.path.poses) :
            path_point = i.pose.position

            global_path_point = [path_point.x - vehicle_position.x, path_point.y - vehicle_position.y, 1]
            local_path_point = det_trans_matrix.dot(global_path_point)    
            #print("g :", global_path_point)
            #print("l :", local_path_point)
            if local_path_point[0]>0 :
                dis = sqrt(local_path_point[0]**2 + local_path_point[1]**2)
                if dis >= self.lfd :
                    self.forward_point = local_path_point
                    self.is_look_forward_point = True
                    break
        
        
        #: (3) Steering ê°ë„ ê³„ì‚°
        
        # ì œì–´ ì…ë ¥ì„ ìœ„í•œ Steering ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # theta ëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ì¢Œí‘œì˜ ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # Steering ê°ë„ëŠ” Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì˜ ê°ë„ ê³„ì‚° ìˆ˜ì‹ì„ ì ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        theta = atan2(self.forward_point[1], self.forward_point[0])
        steering = atan2( ( 2 * self.vehicle_length * sin(theta)), sqrt(self.forward_point[0]**2 + self.forward_point[1]**2))

        return steering

class pidControl:
    def __init__(self):
        self.p_gain = 0.3
        self.i_gain = 0.00
        self.d_gain = 0.03
        self.prev_error = 0
        self.i_control = 0
        self.controlTime = 0.02

    def pid(self,target_vel, current_vel):
        error = target_vel - current_vel

        # (4) PID ì œì–´ ìƒì„±
        
        # ì¢…ë°©í–¥ ì œì–´ë¥¼ ìœ„í•œ PID ì œì–´ê¸°ëŠ” í˜„ì¬ ì†ë„ì™€ ëª©í‘œ ì†ë„ ê°„ ì°¨ì´ë¥¼ ì¸¡ì •í•˜ì—¬ Accel/Brake ê°’ì„ ê²°ì • í•©ë‹ˆë‹¤.
        # ê° PID ì œì–´ë¥¼ ìœ„í•œ Gain ê°’ì€ "class pidContorl" ì— ì •ì˜ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
        # ê° PID Gain ê°’ì„ ì§ì ‘ íŠœë‹í•˜ê³  ì•„ë˜ ìˆ˜ì‹ì„ ì±„ì›Œ ë„£ì–´ P I D ì œì–´ê¸°ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

        p_control = self.p_gain * error
        self.i_control += self.i_gain * error * self.controlTime
        d_control = self.d_gain * ((error - self.prev_error) / self.controlTime)

        output = p_control + self.i_control + d_control
        self.prev_error = error

        
        # print("p_control ", p_control)
        # print("i_control ", self.i_control)
        # print("d_control ", d_control)

        return output

class velocityPlanning:
    def __init__ (self,car_max_speed, road_friciton):
        self.car_max_speed = car_max_speed
        self.road_friction = road_friciton

    def curvedBaseVelocity(self, gloabl_path, point_num):
        out_vel_plan = []

        for i in range(0,point_num):
            out_vel_plan.append(self.car_max_speed)

        for i in range(point_num, len(gloabl_path.poses) - point_num):
            x_list = []
            y_list = []
            for box in range(-point_num, point_num):
                x = gloabl_path.poses[i+box].pose.position.x
                y = gloabl_path.poses[i+box].pose.position.y
                x_list.append([-2*x, -2*y ,1])
                y_list.append((-x*x) - (y*y))

            # (5) ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
            # ë„ë¡œì˜ ê³¡ë¥  ë°˜ê²½ì„ ê³„ì‚°í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì…ë‹ˆë‹¤.
            # Path ë°ì´í„°ì˜ ì¢Œí‘œë¥¼ ì´ìš©í•´ì„œ ê³¡ì„ ì˜ ê³¡ë¥ ì„ êµ¬í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì„ ì‘ì„±í•©ë‹ˆë‹¤.
            # ì›ì˜ ì¢Œí‘œë¥¼ êµ¬í•˜ëŠ” í–‰ë ¬ ê³„ì‚°ì‹, ìµœì†Œ ììŠ¹ë²•ì„ ì´ìš©í•˜ëŠ” ë°©ì‹ ë“± ê³¡ë¥  ë°˜ì§€ë¦„ì„ êµ¬í•˜ê¸° ìœ„í•œ ì‹ì„ ì ìš© í•©ë‹ˆë‹¤.
            # ì ìš©í•œ ìˆ˜ì‹ì„ í†µí•´ ê³¡ë¥  ë°˜ì§€ë¦„ "r" ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
            A = np.array(x_list)
            B = np.array(y_list)
            result = np.linalg.lstsq(A, B, rcond=None)

            if len(result[0]) == 0:
                continue

            r = sqrt(result[0][0] ** 2 + result[0][1] ** 2)  # ê³¡ë¥  ë°˜ê²½ ê³„ì‚°

            
            gravityAcc = 9.8
            # (6) ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
            
            # ê³„ì‚° í•œ ê³¡ë¥  ë°˜ê²½ì„ ì´ìš©í•˜ì—¬ ìµœê³  ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            # í‰í‰í•œ ë„ë¡œì¸ ê²½ìš° ìµœëŒ€ ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. 
            # ê³¡ë¥  ë°˜ê²½ x ì¤‘ë ¥ê°€ì†ë„ x ë„ë¡œì˜ ë§ˆì°° ê³„ìˆ˜ ê³„ì‚° ê°’ì˜ ì œê³±ê·¼ì´ ë©ë‹ˆë‹¤.
            print("r : " + str(r))
            print("friction : " + str(self.road_friction))
            print("gravityAcc : " + str(gravityAcc))
            v_max = sqrt(r * self.road_friction * gravityAcc)  # ìµœëŒ€ ì†ë„ ê³„íš
            print("v_max: " + str(v_max))
            print("\n")
            if v_max > self.car_max_speed:
                v_max = self.car_max_speed

            out_vel_plan.append(v_max)
        for i in range(len(gloabl_path.poses) - point_num, len(gloabl_path.poses)-10):
            out_vel_plan.append(30)

        for i in range(len(gloabl_path.poses) - 10, len(gloabl_path.poses)):
            out_vel_plan.append(0)

        return out_vel_plan

if __name__ == '__main__':
    try:
        test_track=pure_pursuit()
    except rospy.ROSInterruptException:
        pass

```

<br>



#### 3-2) ê²°ê³¼

ì—…ë¡œë“œ ì˜ˆì •

<br>





---

## 4. advanced_purepursuit.py

#### 4-1) To Do

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow,atan2
from geometry_msgs.msg import Point,PoseWithCovarianceStamped
from nav_msgs.msg import Odometry,Path
from morai_msgs.msg import CtrlCmd,EgoVehicleStatus
import numpy as np
import tf
from tf.transformations import euler_from_quaternion,quaternion_from_euler

# advanced_purepursuit ì€ ì°¨ëŸ‰ì˜ ì°¨ëŸ‰ì˜ ì¢… íš¡ ë°©í–¥ ì œì–´ ì˜ˆì œì…ë‹ˆë‹¤.
# Purpusuit ì•Œê³ ë¦¬ì¦˜ì˜ Look Ahead Distance ê°’ì„ ì†ë„ì— ë¹„ë¡€í•˜ì—¬ ê°€ë³€ ê°’ìœ¼ë¡œ ë§Œë“¤ì–´ íš¡ ë°©í–¥ ì£¼í–‰ ì„±ëŠ¥ì„ ì˜¬ë¦½ë‹ˆë‹¤.
# íš¡ë°©í–¥ ì œì–´ ì…ë ¥ì€ ì£¼í–‰í•  Local Path (ì§€ì—­ê²½ë¡œ) ì™€ ì°¨ëŸ‰ì˜ ìƒíƒœ ì •ë³´ Odometry ë¥¼ ë°›ì•„ ì°¨ëŸ‰ì„ ì œì–´ í•©ë‹ˆë‹¤.
# ì¢…ë°©í–¥ ì œì–´ ì…ë ¥ì€ ëª©í‘œ ì†ë„ë¥¼ ì§€ì • í•œë’¤ ëª©í‘œ ì†ë„ì— ë„ë‹¬í•˜ê¸° ìœ„í•œ Throttle control ì„ í•©ë‹ˆë‹¤.
# ì¢…ë°©í–¥ ì œì–´ ì…ë ¥ì€ longlCmdType 1(Throttle control) ì´ìš©í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. subscriber, publisher ì„ ì–¸
# 2. ì†ë„ ë¹„ë¡€ Look Ahead Distance ê°’ ì„¤ì •
# 3. ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
# 4. Steering ê°ë„ ê³„ì‚°
# 5. PID ì œì–´ ìƒì„±
# 6. ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
# 7. ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
# 8. ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish

#TODO: (0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹
'''
# advanced_purepursuit ì€ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ê°•í™” í•œ ì˜ˆì œì…ë‹ˆë‹¤.
# ì´ì „ê¹Œì§€ ì‚¬ìš©í•œ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì€ ê³ ì •ëœ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°’ì„ ì‚¬ìš©í•˜ì˜€ìŠµë‹ˆë‹¤.
# í•´ë‹¹ ì˜ˆì œì—ì„œëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°’ì„ ì£¼í–‰ ì†ë„ì— ë¹„ë¡€í•œ ê°’ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
# ì´ë•Œ ìµœì†Œ ìµœëŒ€ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
# ì£¼í–‰ ì†ë„ì— ë¹„ë¡€í•œ ê°’ìœ¼ë¡œ ë³€ê²½ í•œ ë’¤ "self.lfd_gain" ì„ ë³€ê²½ í•˜ì—¬ì„œ ì§ì ‘ ì œì–´ê¸° ì„±ëŠ¥ì„ íŠœë‹ í•´ë³´ì„¸ìš”.
# 

'''
class pure_pursuit :
    def __init__(self):
        rospy.init_node('pure_pursuit', anonymous=True)

        #TODO: (1) subscriber, publisher ì„ ì–¸
        '''
        # Local/Gloabl Path ì™€ Odometry Ego Status ë°ì´í„°ë¥¼ ìˆ˜ì‹  í•  Subscriber ë¥¼ ë§Œë“¤ê³  
        # CtrlCmd ë¥¼ ì‹œë®¬ë ˆì´í„°ë¡œ ì „ì†¡ í•  publisher ë³€ìˆ˜ë¥¼ ë§Œë“ ë‹¤.
        # CtrlCmd ì€ 1ì¥ì„ ì°¸ê³  í•œë‹¤.
        # Ego topic ë°ì´í„°ëŠ” ì°¨ëŸ‰ì˜ í˜„ì¬ ì†ë„ë¥¼ ì•Œê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        # Gloabl Path ë°ì´í„°ëŠ” ê²½ë¡œì˜ ê³¡ë¥ ì„ ì´ìš©í•œ ì†ë„ ê³„íšì„ ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        rospy.Subscriber("/global_path" )
        rospy.Subscriber("local_path" )
        rospy.Subscriber("odom" )
        rospy.Subscriber("/Ego_topic" )
        self.ctrl_cmd_pub = 

        '''

        self.ctrl_cmd_msg = CtrlCmd()
        self.ctrl_cmd_msg.longlCmdType = 1

        self.is_path = False
        self.is_odom = False 
        self.is_status = False
        self.is_global_path = False

        self.is_look_forward_point = False

        self.forward_point = Point()
        self.current_postion = Point()

        self.vehicle_length = 2.6
        self.lfd = 8
        self.min_lfd = 5
        self.max_lfd = 30
        self.lfd_gain = 0.78
        self.target_velocity = 60

        self.pid = pidControl()
        self.vel_planning = velocityPlanning(self.target_velocity/3.6, 0.15)
        while True:
            if self.is_global_path == True:
                self.velocity_list = self.vel_planning.curvedBaseVelocity(self.global_path, 50)
                break
            else:
                rospy.loginfo('Waiting global path data')

        rate = rospy.Rate(30) # 30hz
        while not rospy.is_shutdown():

            if self.is_path == True and self.is_odom == True and self.is_status == True:
                
                self.current_waypoint = self.get_current_waypoint(self.status_msg,self.global_path)
                self.target_velocity = self.velocity_list[self.current_waypoint]*3.6

                steering = self.calc_pure_pursuit()
                if self.is_look_forward_point :
                    self.ctrl_cmd_msg.steering = steering
                else : 
                    rospy.loginfo("no found forward point")
                    self.ctrl_cmd_msg.steering = 0.0

                output = self.pid.pid(self.target_velocity,self.status_msg.velocity.x*3.6)

                if output > 0.0:
                    self.ctrl_cmd_msg.accel = output
                    self.ctrl_cmd_msg.brake = 0.0
                else:
                    self.ctrl_cmd_msg.accel = 0.0
                    self.ctrl_cmd_msg.brake = -output

                #TODO: (8) ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish
                '''
                # ì œì–´ì…ë ¥ ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.ctrl_cmd_pub.
                
                '''
                
            rate.sleep()

    def path_callback(self,msg):
        self.is_path=True
        self.path=msg  

    def odom_callback(self,msg):
        self.is_odom=True
        odom_quaternion=(msg.pose.pose.orientation.x,msg.pose.pose.orientation.y,msg.pose.pose.orientation.z,msg.pose.pose.orientation.w)
        _,_,self.vehicle_yaw=euler_from_quaternion(odom_quaternion)
        self.current_postion.x=msg.pose.pose.position.x
        self.current_postion.y=msg.pose.pose.position.y

    def status_callback(self,msg): ## Vehicl Status Subscriber 
        self.is_status=True
        self.status_msg=msg    
        
    def global_path_callback(self,msg):
        self.global_path = msg
        self.is_global_path = True
    
    def get_current_waypoint(self,ego_status,global_path):
        min_dist = float('inf')        
        currnet_waypoint = -1
        for i,pose in enumerate(global_path.poses):
            dx = ego_status.position.x - pose.pose.position.x
            dy = ego_status.position.y - pose.pose.position.y

            dist = sqrt(pow(dx,2)+pow(dy,2))
            if min_dist > dist :
                min_dist = dist
                currnet_waypoint = i
        return currnet_waypoint

    def calc_pure_pursuit(self,):

        #TODO: (2) ì†ë„ ë¹„ë¡€ Look Ahead Distance ê°’ ì„¤ì •
        '''
        # ì°¨ëŸ‰ ì†ë„ì— ë¹„ë¡€í•˜ì—¬ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°€ ë³€í•˜ëŠ” ìˆ˜ì‹ì„ êµ¬í˜„ í•©ë‹ˆë‹¤.
        # ì´ë•Œ 'self.lfd' ê°’ì€ ìµœì†Œì™€ ìµœëŒ€ ê°’ì„ ë„˜ì–´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤.
        # "self.min_lfd","self.max_lfd", "self.lfd_gain" ì„ ë¯¸ë¦¬ ì •ì˜í•©ë‹ˆë‹¤.
        # ìµœì†Œ ìµœëŒ€ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°’ê³¼ ì†ë„ì— ë¹„ë¡€í•œ lfd_gain ê°’ì„ ì§ì ‘ ë³€ê²½í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        # ì´ˆê¸° ì •ì˜í•œ ë³€ìˆ˜ ë“¤ì˜ ê°’ì„ ë³€ê²½í•˜ë©° ì†ë„ì— ë¹„ë¡€í•´ì„œ ì „ë°©ì£¼ì‹œê±°ë¦¬ ê°€ ë³€í•˜ëŠ” advanced_purepursuit ì˜ˆì œë¥¼ ì™„ì„±í•˜ì„¸ìš”.
        # 
        self.lfd = 

        rospy.loginfo(self.lfd)

        '''
        
        vehicle_position=self.current_postion
        self.is_look_forward_point= False

        translation = [vehicle_position.x, vehicle_position.y]

        #TODO: (3) ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
        '''
        # Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰ í•˜ê¸° ìœ„í•´ì„œ ì°¨ëŸ‰ ê¸°ì¤€ì˜ ì¢Œí‘œê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ í˜„ì¬ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œê³„ë¡œ ì¢Œí‘œ ë³€í™˜ì´ í•„ìš”í•©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì‘ì„±í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë³€í™˜ í›„ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì´ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•˜ê²Œ ë©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì´ìš©í•´ Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë°”ê¾¸ëŠ” ë°˜ë³µ ë¬¸ì„ ì‘ì„± í•œ ë’¤
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ê³„ì‚°í•˜ëŠ” ë¡œì§ì„ ì‘ì„± í•˜ì„¸ìš”.

        trans_matrix = np.array([   [                       ,                       ,               ],
                                    [                       ,                       ,               ],
                                    [0                      ,0                      ,1              ]])

        det_trans_matrix = np.linalg.inv(trans_matrix)

        for num,i in enumerate(self.path.poses) :
            path_point = 

            global_path_point = [ , , 1]
            local_path_point = det_trans_matrix.dot(global_path_point)    

            if local_path_point[0]>0 :
                dis = 
                if dis >= self.lfd :
                    self.forward_point = 
                    self.is_look_forward_point = True
                    break

        '''
        #TODO: (4) Steering ê°ë„ ê³„ì‚°
        '''
        # ì œì–´ ì…ë ¥ì„ ìœ„í•œ Steering ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # theta ëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ì¢Œí‘œì˜ ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # Steering ê°ë„ëŠ” Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì˜ ê°ë„ ê³„ì‚° ìˆ˜ì‹ì„ ì ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        theta = 
        steering = 

        '''

        return steering

class pidControl:
    def __init__(self):
        self.p_gain = 0.3
        self.i_gain = 0.00
        self.d_gain = 0.03
        self.prev_error = 0
        self.i_control = 0
        self.controlTime = 0.02

    def pid(self,target_vel, current_vel):
        error = target_vel - current_vel

        #TODO: (5) PID ì œì–´ ìƒì„±
        '''
        # ì¢…ë°©í–¥ ì œì–´ë¥¼ ìœ„í•œ PID ì œì–´ê¸°ëŠ” í˜„ì¬ ì†ë„ì™€ ëª©í‘œ ì†ë„ ê°„ ì°¨ì´ë¥¼ ì¸¡ì •í•˜ì—¬ Accel/Brake ê°’ì„ ê²°ì • í•©ë‹ˆë‹¤.
        # ê° PID ì œì–´ë¥¼ ìœ„í•œ Gain ê°’ì€ "class pidContorl" ì— ì •ì˜ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
        # ê° PID Gain ê°’ì„ ì§ì ‘ íŠœë‹í•˜ê³  ì•„ë˜ ìˆ˜ì‹ì„ ì±„ì›Œ ë„£ì–´ P I D ì œì–´ê¸°ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

        p_control = 
        self.i_control += 
        d_control = 

        output = 
        self.prev_error = 

        '''

        return output

class velocityPlanning:
    def __init__ (self,car_max_speed, road_friciton):
        self.car_max_speed = car_max_speed
        self.road_friction = road_friciton

    def curvedBaseVelocity(self, gloabl_path, point_num):
        out_vel_plan = []

        for i in range(0,point_num):
            out_vel_plan.append(self.car_max_speed)

        for i in range(point_num, len(gloabl_path.poses) - point_num):
            x_list = []
            y_list = []
            for box in range(-point_num, point_num):
                x = gloabl_path.poses[i+box].pose.position.x
                y = gloabl_path.poses[i+box].pose.position.y
                x_list.append([-2*x, -2*y ,1])
                y_list.append((-x*x) - (y*y))

            #TODO: (6) ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
            '''
            # ë„ë¡œì˜ ê³¡ë¥  ë°˜ê²½ì„ ê³„ì‚°í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì…ë‹ˆë‹¤.
            # Path ë°ì´í„°ì˜ ì¢Œí‘œë¥¼ ì´ìš©í•´ì„œ ê³¡ì„ ì˜ ê³¡ë¥ ì„ êµ¬í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì„ ì‘ì„±í•©ë‹ˆë‹¤.
            # ì›ì˜ ì¢Œí‘œë¥¼ êµ¬í•˜ëŠ” í–‰ë ¬ ê³„ì‚°ì‹, ìµœì†Œ ììŠ¹ë²•ì„ ì´ìš©í•˜ëŠ” ë°©ì‹ ë“± ê³¡ë¥  ë°˜ì§€ë¦„ì„ êµ¬í•˜ê¸° ìœ„í•œ ì‹ì„ ì ìš© í•©ë‹ˆë‹¤.
            # ì ìš©í•œ ìˆ˜ì‹ì„ í†µí•´ ê³¡ë¥  ë°˜ì§€ë¦„ "r" ì„ ê³„ì‚°í•©ë‹ˆë‹¤.

            r = 

            '''

            #TODO: (7) ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
            '''
            # ê³„ì‚° í•œ ê³¡ë¥  ë°˜ê²½ì„ ì´ìš©í•˜ì—¬ ìµœê³  ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            # í‰í‰í•œ ë„ë¡œì¸ ê²½ìš° ìµœëŒ€ ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. 
            # ê³¡ë¥  ë°˜ê²½ x ì¤‘ë ¥ê°€ì†ë„ x ë„ë¡œì˜ ë§ˆì°° ê³„ìˆ˜ ê³„ì‚° ê°’ì˜ ì œê³±ê·¼ì´ ë©ë‹ˆë‹¤.
            v_max = 

            '''

            if v_max > self.car_max_speed:
                v_max = self.car_max_speed
            out_vel_plan.append(v_max)

        for i in range(len(gloabl_path.poses) - point_num, len(gloabl_path.poses)-10):
            out_vel_plan.append(30)

        for i in range(len(gloabl_path.poses) - 10, len(gloabl_path.poses)):
            out_vel_plan.append(0)

        return out_vel_plan

if __name__ == '__main__':
    try:
        test_track=pure_pursuit()
    except rospy.ROSInterruptException:
        pass

```

<br>


#### 4-2) ì½”ë“œ

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow,atan2
from geometry_msgs.msg import Point,PoseWithCovarianceStamped
from nav_msgs.msg import Odometry,Path
from morai_msgs.msg import CtrlCmd,EgoVehicleStatus
import numpy as np
import tf
from tf.transformations import euler_from_quaternion,quaternion_from_euler

# advanced_purepursuit ì€ ì°¨ëŸ‰ì˜ ì°¨ëŸ‰ì˜ ì¢… íš¡ ë°©í–¥ ì œì–´ ì˜ˆì œì…ë‹ˆë‹¤.
# Purpusuit ì•Œê³ ë¦¬ì¦˜ì˜ Look Ahead Distance ê°’ì„ ì†ë„ì— ë¹„ë¡€í•˜ì—¬ ê°€ë³€ ê°’ìœ¼ë¡œ ë§Œë“¤ì–´ íš¡ ë°©í–¥ ì£¼í–‰ ì„±ëŠ¥ì„ ì˜¬ë¦½ë‹ˆë‹¤.
# íš¡ë°©í–¥ ì œì–´ ì…ë ¥ì€ ì£¼í–‰í•  Local Path (ì§€ì—­ê²½ë¡œ) ì™€ ì°¨ëŸ‰ì˜ ìƒíƒœ ì •ë³´ Odometry ë¥¼ ë°›ì•„ ì°¨ëŸ‰ì„ ì œì–´ í•©ë‹ˆë‹¤.
# ì¢…ë°©í–¥ ì œì–´ ì…ë ¥ì€ ëª©í‘œ ì†ë„ë¥¼ ì§€ì • í•œë’¤ ëª©í‘œ ì†ë„ì— ë„ë‹¬í•˜ê¸° ìœ„í•œ Throttle control ì„ í•©ë‹ˆë‹¤.
# ì¢…ë°©í–¥ ì œì–´ ì…ë ¥ì€ longlCmdType 1(Throttle control) ì´ìš©í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. subscriber, publisher ì„ ì–¸
# 2. ì†ë„ ë¹„ë¡€ Look Ahead Distance ê°’ ì„¤ì •
# 3. ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
# 4. Steering ê°ë„ ê³„ì‚°
# 5. PID ì œì–´ ìƒì„±
# 6. ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
# 7. ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
# 8. ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish

# (0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹

# advanced_purepursuit ì€ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ê°•í™” í•œ ì˜ˆì œì…ë‹ˆë‹¤.
# ì´ì „ê¹Œì§€ ì‚¬ìš©í•œ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì€ ê³ ì •ëœ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°’ì„ ì‚¬ìš©í•˜ì˜€ìŠµë‹ˆë‹¤.
# í•´ë‹¹ ì˜ˆì œì—ì„œëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°’ì„ ì£¼í–‰ ì†ë„ì— ë¹„ë¡€í•œ ê°’ìœ¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.
# ì´ë•Œ ìµœì†Œ ìµœëŒ€ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
# ì£¼í–‰ ì†ë„ì— ë¹„ë¡€í•œ ê°’ìœ¼ë¡œ ë³€ê²½ í•œ ë’¤ "self.lfd_gain" ì„ ë³€ê²½ í•˜ì—¬ì„œ ì§ì ‘ ì œì–´ê¸° ì„±ëŠ¥ì„ íŠœë‹ í•´ë³´ì„¸ìš”.
# 


class pure_pursuit :
    def __init__(self):
        rospy.init_node('pure_pursuit', anonymous=True)

        #T(1) subscriber, publisher ì„ ì–¸
        
        # Local/Gloabl Path ì™€ Odometry Ego Status ë°ì´í„°ë¥¼ ìˆ˜ì‹  í•  Subscriber ë¥¼ ë§Œë“¤ê³  
        # CtrlCmd ë¥¼ ì‹œë®¬ë ˆì´í„°ë¡œ ì „ì†¡ í•  publisher ë³€ìˆ˜ë¥¼ ë§Œë“ ë‹¤.
        # CtrlCmd ì€ 1ì¥ì„ ì°¸ê³  í•œë‹¤.
        # Ego topic ë°ì´í„°ëŠ” ì°¨ëŸ‰ì˜ í˜„ì¬ ì†ë„ë¥¼ ì•Œê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        # Gloabl Path ë°ì´í„°ëŠ” ê²½ë¡œì˜ ê³¡ë¥ ì„ ì´ìš©í•œ ì†ë„ ê³„íšì„ ìœ„í•´ ì‚¬ìš©í•œë‹¤.

        rospy.Subscriber("/global_path", Path, self.global_path_callback)
        rospy.Subscriber("local_path", Path, self.path_callback )
        rospy.Subscriber("/odom", Odometry, self.odom_callback)
        rospy.Subscriber( 'Ego_topic' , EgoVehicleStatus , self.status_callback)

        # Publish
        self.ctrl_cmd_pub = rospy.Publisher('ctrl_cmd', CtrlCmd, queue_size=10)
        self.ctrl_cmd_msg = CtrlCmd()
        self.ctrl_cmd_msg.longlCmdType = 1

        # Trigger
        self.is_path = False      # Local Pathë¥¼ ì°¾ì•˜ëŠ”ì§€ ì—¬ë¶€
        self.is_odom = False      # Odometry(Egoì°¨ëŸ‰ì˜ ìœ„ì¹˜, ë°©í–¥) ë°›ì•˜ëŠ”ì§€ ì—¬ë¶€ 
        self.is_status = False    # ì°¨ëŸ‰ ì •ë³´ ë°›ì•˜ëŠ”ì§€ ì—¬ë¶€
        self.is_global_path = False # Global Pathë¥¼ ì°¾ì•˜ëŠ”ì§€ ì—¬ë¶€


        self.is_look_forward_point = False  

        self.forward_point = Point()       # ì „ë°© ë…¸ë“œ ê°ì²´
        self.current_postion = Point()     # í˜„ì¬ ë…¸ë“œ ê°ì²´


        self.vehicle_length = 2.6     # ì°¨ëŸ‰ ê¸¸ì´ 
        self.lfd = 8                  # ì „ë°©ì£¼ì‹œê±°ë¦¬ [m]
        self.min_lfd = 5              # ìµœì†Œ ì „ë°©ì£¼ì‹œê±°ë¦¬ [m]
        self.max_lfd = 30             # ìµœëŒ€ ì „ë°©ì£¼ì‹œê±°ë¦¬[m]
        self.lfd_gain = 0.78          # ì „ë°©ì£¼ì‹œê±°ë¦¬ ì¦ê°€ìœ¨(?) -> ì ì ˆí•œ lfd_gainê°’ì„ ì°¾ì•„ì•¼í•¨
        self.target_velocity = 20     # ìµœëŒ€ ì†ë„[km/h]

        self.pid = pidControl() # p_gain, i_gain, d_gain, prev_error, i_control, controlTime
        self.vel_planning = velocityPlanning(self.target_velocity/3.6, 0.7) # ë§¤ê°œë³€ìˆ˜ : self,car_max_speed[m/së¡œ ë³€í™˜], road_friciton
        while True:
            if self.is_global_path == True:
                # ê³„íší•œ ì†ë„ ë¦¬ìŠ¤íŠ¸ ë°›ì•„ì˜¤ê¸°
                self.velocity_list = self.vel_planning.curvedBaseVelocity(self.global_path, 50) #gloabl_path, point_num
                break
            else:
                rospy.loginfo('Waiting global path data')

        rate = rospy.Rate(30) # 30hz
        while not rospy.is_shutdown(): # ROS ì‹œìŠ¤í…œì´ ì¢…ë£Œë˜ì§€ ì•ŠëŠ” í•œ ê³„ì† ì‹¤í–‰

            if self.is_path == True and self.is_odom == True and self.is_status == True:
                
                self.current_waypoint = self.get_current_waypoint(self.status_msg, self.global_path) #ì°¨ëŸ‰ì˜ ìƒíƒœ, ì „ì—­ê²½ë¡œ
                self.target_velocity = self.velocity_list[self.current_waypoint]*3.6  # [km/h]ë¡œ ë³€í™˜

                steering = self.calc_pure_pursuit()
                #ì „ë°©ì£¼ì‹œì§€ì  ì°¾ì€ ì—¬ë¶€ íŒë³„ 
                if self.is_look_forward_point : #ì°¾ì€ ê²½ìš°ì—ëŠ” steeringê°’ update
                    self.ctrl_cmd_msg.steering = steering
                else : 
                    rospy.loginfo("no found forward point") #ëª» ì°¾ì€ ê²½ìš°
                    self.ctrl_cmd_msg.steering = 0.0

                # PID ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ê°€ì†ë„ ë˜ëŠ” ì œë™ì„ ê³„ì‚°í•©ë‹ˆë‹¤.
                output = self.pid.pid(self.target_velocity,self.status_msg.velocity.x*3.6)

                if output > 0.0:
                    self.ctrl_cmd_msg.accel = output
                    self.ctrl_cmd_msg.brake = 0.0
                else:
                    self.ctrl_cmd_msg.accel = 0.0
                    self.ctrl_cmd_msg.brake = -output

                # (8) ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish
                
                # ì œì–´ì…ë ¥ ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.ctrl_cmd_pub.publish(self.ctrl_cmd_msg)
                
                
            rate.sleep()

    def path_callback(self,msg):
        self.is_path=True
        self.path=msg  

    def odom_callback(self,msg):
        self.is_odom=True
        odom_quaternion=(msg.pose.pose.orientation.x,msg.pose.pose.orientation.y,msg.pose.pose.orientation.z,msg.pose.pose.orientation.w)
        _,_,self.vehicle_yaw=euler_from_quaternion(odom_quaternion) 
        self.current_postion.x=msg.pose.pose.position.x
        self.current_postion.y=msg.pose.pose.position.y

    def status_callback(self,msg): ## Vehicle Status Subscriber 
        self.is_status=True
        self.status_msg=msg    
        
    def global_path_callback(self,msg):
        self.global_path = msg
        self.is_global_path = True
    
    def get_current_waypoint(self,ego_status,global_path):
        min_dist = float('inf')  # í˜„ì¬ê¹Œì§€ ì°¾ì€ ìµœì†Œ ê±°ë¦¬ 
        currnet_waypoint = -1    # ìµœì†Œ ê±°ë¦¬ì— í•´ë‹¹í•˜ëŠ” waypointì˜ ì¸ë±ìŠ¤ ë‚˜íƒ€ëƒ„
        for i,pose in enumerate(global_path.poses):   # global_path.poses : ì „ì—­ ê²½ë¡œì˜ ëª¨ë“  waypoint
            dx = ego_status.position.x - pose.pose.position.x  
            dy = ego_status.position.y - pose.pose.position.y

            dist = sqrt(pow(dx,2)+pow(dy,2))  # í•´ë‹¹ pointê¹Œì§€ì˜ ê±°ë¦¬
            if min_dist > dist : 
                min_dist = dist 
                currnet_waypoint = i
        return currnet_waypoint

    def calc_pure_pursuit(self,):

        #(2) ì†ë„ ë¹„ë¡€ Look Ahead Distance ê°’ ì„¤ì •
        '''
        # ì°¨ëŸ‰ ì†ë„ì— ë¹„ë¡€í•˜ì—¬ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°€ ë³€í•˜ëŠ” ìˆ˜ì‹ì„ êµ¬í˜„ í•©ë‹ˆë‹¤.
        # ì´ë•Œ 'self.lfd' ê°’ì€ ìµœì†Œì™€ ìµœëŒ€ ê°’ì„ ë„˜ì–´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤.
        # "self.min_lfd","self.max_lfd", "self.lfd_gain" ì„ ë¯¸ë¦¬ ì •ì˜í•©ë‹ˆë‹¤.
        # ìµœì†Œ ìµœëŒ€ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°’ê³¼ ì†ë„ì— ë¹„ë¡€í•œ lfd_gain ê°’ì„ ì§ì ‘ ë³€ê²½í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        # ì´ˆê¸° ì •ì˜í•œ ë³€ìˆ˜ ë“¤ì˜ ê°’ì„ ë³€ê²½í•˜ë©° ì†ë„ì— ë¹„ë¡€í•´ì„œ ì „ë°©ì£¼ì‹œê±°ë¦¬ ê°€ ë³€í•˜ëŠ” advanced_purepursuit ì˜ˆì œë¥¼ ì™„ì„±í•˜ì„¸ìš”.
        # 
        self.lfd = 

        rospy.loginfo(self.lfd)

        '''
        self.lfd = self.lfd_gain * self.status_msg.velocity.x  #ì ì ˆí•œ lfdê°’ ì°¾ì•„ì•¼í•¨
        self.lfd = max(self.min_lfd, min(self.max_lfd, self.lfd))  # ìµœì†Œê°’ê³¼ ìµœëŒ€ê°’ ì‚¬ì´ì˜ ê°’ìœ¼ë¡œ ì¡°ì •
        rospy.loginfo(self.lfd)  # í˜„ì¬ lfd ê°’ ë¡œê·¸ë¡œ ì¶œë ¥

        
        vehicle_position=self.current_postion # ì´ì „ì— ê³„ì‚°ëœ í˜„ì¬ ì°¨ëŸ‰ ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜´
        self.is_look_forward_point= False # ì „ë°© ì£¼ì‹œ ì§€ì ì„ ì•„ì§ ì°¾ì§€ ì•Šì•˜ìŒ

        translation = [vehicle_position.x, vehicle_position.y]

        # (3) ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
        
        # Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰ í•˜ê¸° ìœ„í•´ì„œ ì°¨ëŸ‰ ê¸°ì¤€ì˜ ì¢Œí‘œê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ í˜„ì¬ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œê³„ë¡œ ì¢Œí‘œ ë³€í™˜ì´ í•„ìš”í•©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì‘ì„±í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë³€í™˜ í›„ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì´ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•˜ê²Œ ë©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì´ìš©í•´ Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë°”ê¾¸ëŠ” ë°˜ë³µ ë¬¸ì„ ì‘ì„± í•œ ë’¤
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ê³„ì‚°í•˜ëŠ” ë¡œì§ì„ ì‘ì„± í•˜ì„¸ìš”.

        # ì°¨ëŸ‰ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì¢Œí‘œ ë³€í™˜ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ ë³€í™˜ í–‰ë ¬ì„ ìƒì„±
        trans_matrix = np.array([[cos(self.vehicle_yaw),-sin(self.vehicle_yaw) ,0],
                                [sin(self.vehicle_yaw),cos(self.vehicle_yaw),0],
                                [0,0,1]])
        # ë³€í™˜ í–‰ë ¬ì˜ ì—­í–‰ë ¬ì„ ê³„ì‚°
        det_trans_matrix = np.linalg.inv(trans_matrix)

        # ê²½ë¡œ ìƒì˜ ê° ì ì— ëŒ€í•´ ë°˜ë³µ
        for num,i in enumerate(self.path.poses) :
            # í•´ë‹¹ ê²½ë¡œ ì ì˜ ìœ„ì¹˜
            path_point = i.pose.position
             # ì°¨ëŸ‰ ì¢Œí‘œê³„ë¡œ ì ì„ ë³€í™˜
            global_path_point = [path_point.x - vehicle_position.x, path_point.y - vehicle_position.y, 1] # 3ì°¨ì› ë²¡í„°
            local_path_point = det_trans_matrix.dot(global_path_point) #ì°¨ëŸ‰ ì¢Œí‘œê³„ë¡œ ë³€í™˜í•œ ì 
            #print("g :", global_path_point)
            #print("l :", local_path_point)
            # if local_path_point[0]>0 :
            #     dis = sqrt(local_path_point[0]**2 + local_path_point[1]**2)
            #     if dis >= self.lfd :
            #         self.forward_point = local_path_point
            #         self.is_look_forward_point = True
            #         break

            # ë³€í™˜ëœ ì ì´ ì°¨ëŸ‰ ì•ì— ìˆëŠ”ì§€ í™•ì¸
            if local_path_point[0] > 0:
                # ê°ë„ë¥¼ ê³„ì‚°í•˜ì—¬ ì •ë©´ì— ìˆëŠ”ì§€ í™•ì¸
                angle_to_point = atan2(local_path_point[1], local_path_point[0])
                if abs(angle_to_point) < pi / 2:  # ì •ë©´ì— ìˆëŠ” ê²½ìš°ì—ë§Œ
                    #ì „ë°©ì£¼ì‹œì§€ì  ì°¾ê¸°
                    #ì°¨ëŸ‰ì¢Œí‘œê³„ ê¸°ì¤€ ì°¨ëŸ‰ê³¼ ê²½ë¡œì  ì‚¬ì´ì˜ ê±°ë¦¬
                    dis = sqrt(local_path_point[0] ** 2 + local_path_point[1] ** 2)
                    if dis >= self.lfd: # ì „ë°©ì£¼ì‹œê±°ë¦¬ë³´ë‹¤ ë©€ë¦¬ ë–¨ì–´ì§„ ì  ì°¾ê¸°
                        self.forward_point = local_path_point #ì „ë°©ì£¼ì‹œì§€ì ìœ¼ë¡œ ì„ íƒëœ ì  ì €ì¥
                        self.is_look_forward_point = True #ì „ë°©ì£¼ì‹œì§€ì  ì°¾ê¸° ì™„ë£Œ!
                        break
                        #continue


        
        # (4) Steering ê°ë„ ê³„ì‚°
        
        # ì œì–´ ì…ë ¥ì„ ìœ„í•œ Steering ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # theta ëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ì¢Œí‘œì˜ ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # Steering ê°ë„ëŠ” Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì˜ ê°ë„ ê³„ì‚° ìˆ˜ì‹ì„ ì ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        theta = atan2(self.forward_point[1], self.forward_point[0])
        
        #Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì—ì„œ ì¡°í–¥ê° ìœ ë„ì‹ ì°¸ê³ 
        steering = atan2( ( 2 * self.vehicle_length * sin(theta)), sqrt(self.forward_point[0]**2 + self.forward_point[1]**2))

        return steering

class pidControl:
    def __init__(self):
        self.p_gain = 0.3
        self.i_gain = 0.00
        self.d_gain = 0.03
        self.prev_error = 0
        self.i_control = 0
        self.controlTime = 0.02

    def pid(self,target_vel, current_vel):
        error = target_vel - current_vel

        #(5) PID ì œì–´ ìƒì„±
        
        # ì¢…ë°©í–¥ ì œì–´ë¥¼ ìœ„í•œ PID ì œì–´ê¸°ëŠ” í˜„ì¬ ì†ë„ì™€ ëª©í‘œ ì†ë„ ê°„ ì°¨ì´ë¥¼ ì¸¡ì •í•˜ì—¬ Accel/Brake ê°’ì„ ê²°ì • í•©ë‹ˆë‹¤.
        # ê° PID ì œì–´ë¥¼ ìœ„í•œ Gain ê°’ì€ "class pidContorl" ì— ì •ì˜ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
        # ê° PID Gain ê°’ì„ ì§ì ‘ íŠœë‹í•˜ê³  ì•„ë˜ ìˆ˜ì‹ì„ ì±„ì›Œ ë„£ì–´ P I D ì œì–´ê¸°ë¥¼ ì™„ì„±í•˜ì„¸ìš”.

        p_control = self.p_gain * error
        self.i_control += self.i_gain * error * self.controlTime
        d_control = self.d_gain * ((error - self.prev_error) / self.controlTime)

        output = p_control + self.i_control + d_control
        self.prev_error = error


        return output

class velocityPlanning:
    def __init__ (self,car_max_speed, road_friciton):
        self.car_max_speed = car_max_speed
        self.road_friction = road_friciton

    def curvedBaseVelocity(self, gloabl_path, point_num):
        out_vel_plan = []   # ì†ë„ ê³„íš ê²°ê³¼ ë°°ì—´

        for i in range(0,point_num):
            out_vel_plan.append(self.car_max_speed)  # max_speed ì¶”ê°€ : ì²˜ìŒ ëª‡ê°œì˜ ì§€ì ì—ì„œëŠ” ì°¨ëŸ‰ì˜ ìµœëŒ€ ì†ë„ë¡œ ìœ ì§€í•˜ë„ë¡ ì„¤ì •

        for i in range(point_num, len(gloabl_path.poses) - point_num): #
            x_list = []
            y_list = []
            # í•´ë‹¹ ìœ„ì¹˜ ì£¼ë³€ì˜ ì¢Œí‘œë¥¼ ê°€ì ¸ì™€ x,yê°’ì„ ë”°ë¡œ ì €ì¥í•¨ 
            for box in range(-point_num, point_num):
                x = gloabl_path.poses[i+box].pose.position.x  
                y = gloabl_path.poses[i+box].pose.position.y
                x_list.append([-2*x, -2*y ,1])   # ê²½ë¡œì  nê°œë¥¼ í–‰ë ¬ë¡œ ë§Œë“¬
                y_list.append((-x*x) - (y*y))    # ê²½ë¡œì  nê°œë¥¼ í–‰ë ¬ë¡œ ë§Œë“¬

            # (6) ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
            
            # ë„ë¡œì˜ ê³¡ë¥  ë°˜ê²½ì„ ê³„ì‚°í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì…ë‹ˆë‹¤.
            # Path ë°ì´í„°ì˜ ì¢Œí‘œë¥¼ ì´ìš©í•´ì„œ ê³¡ì„ ì˜ ê³¡ë¥ ì„ êµ¬í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì„ ì‘ì„±í•©ë‹ˆë‹¤.
            # ì›ì˜ ì¢Œí‘œë¥¼ êµ¬í•˜ëŠ” í–‰ë ¬ ê³„ì‚°ì‹, ìµœì†Œ ììŠ¹ë²•ì„ ì´ìš©í•˜ëŠ” ë°©ì‹ ë“± ê³¡ë¥  ë°˜ì§€ë¦„ì„ êµ¬í•˜ê¸° ìœ„í•œ ì‹ì„ ì ìš© í•©ë‹ˆë‹¤.
            # ì ìš©í•œ ìˆ˜ì‹ì„ í†µí•´ ê³¡ë¥  ë°˜ì§€ë¦„ "r" ì„ ê³„ì‚°í•©ë‹ˆë‹¤.

            A = np.array(x_list)
            B = np.array(y_list)
            result = np.linalg.lstsq(A, B, rcond=None)   # ìµœì†Œ ììŠ¹ë²•

            if len(result[0]) == 0:
                continue

            r = sqrt(result[0][0] ** 2 + result[0][1] ** 2)  # ê³¡ë¥  ë°˜ê²½ ê³„ì‚°
            gravityAcc = 9.8

            # (7) ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
            
            # ê³„ì‚° í•œ ê³¡ë¥  ë°˜ê²½ì„ ì´ìš©í•˜ì—¬ ìµœê³  ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
             
            # ê³¡ë¥  ë°˜ê²½ x ì¤‘ë ¥ê°€ì†ë„ x ë„ë¡œì˜ ë§ˆì°° ê³„ìˆ˜ ê³„ì‚° ê°’ì˜ ì œê³±ê·¼ì´ ë©ë‹ˆë‹¤.
            print("r : " + str(r)) # ë„ë¡œì˜ ê³¡ë¥  ë°˜
            print("friction : " + str(self.road_friction)) # ë„ë¡œì˜ ë§ˆì°°ê³„ìˆ˜
            print("gravityAcc : " + str(gravityAcc)) # ì¤‘ë ¥ê°€ì†ë„ 
            v_max = sqrt(r * self.road_friction * gravityAcc)  # ìµœëŒ€ ì†ë„ ê³„íš
            print("v_max: " + str(v_max)) # ê³¡ë¥  ê¸°ë°˜ ìµœëŒ€ ì†ë„ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.
            print("\n")
            
            # í‰í‰í•œ ë„ë¡œ(ê³¡ë¥ ë°˜ì§€ë¦„ ë¬´í•œëŒ€) ì¸ ê²½ìš° ìµœëŒ€ ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. 
            if v_max > self.car_max_speed:
                v_max = self.car_max_speed

            out_vel_plan.append(v_max)

        for i in range(len(gloabl_path.poses) - point_num, len(gloabl_path.poses)-10):
            out_vel_plan.append(30) # point_num ê°œì˜ ì§€ì  ì´ì „ê¹Œì§€ ì†ë„ë¥¼ 30ìœ¼ë¡œ ìœ ì§€í•˜ëŠ” ì—­í• 

        for i in range(len(gloabl_path.poses) - 10, len(gloabl_path.poses)):
            out_vel_plan.append(0) # ê²½ë¡œì˜ ë§ˆì§€ë§‰ 10ê°œì˜ ì§€ì ì— ëŒ€í•´ ì†ë„ë¥¼ 0ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ì°¨ëŸ‰ì´ ì •ì§€í•˜ë„ë¡ í•˜ëŠ” ì—­í• 

        return out_vel_plan

if __name__ == '__main__':
    try:
        test_track=pure_pursuit()
    except rospy.ROSInterruptException:
        pass

```
<br>


#### 4-3) Flow Chart

##### ì „ì²´ ë¡œì§

```
+---------------------+               +-------------------+
|      ì‹œì‘            |               |  ê²½ë¡œ ë° ìƒíƒœ ìˆ˜ì‹  |
+---------------------+               +-------------------+
          |                                   |
          v                                   v
+---------------------+               +-------------------+
|  ROS ë…¸ë“œ ì´ˆê¸°í™”     |               |    ìµœì´ˆ ì„¤ì •      |
+---------------------+               +-------------------+
          |                                   |
          v                                   v
+---------------------+               +-------------------+
| Publisher ë°        |               | ì „ë°© ì£¼ì‹œ ê±°ë¦¬     |
| Subscriber ì„¤ì •     |               |   ê³„íš            |
+---------------------+               +-------------------+
          |                                   |
          v                                   v
+------------------------+          +-------------------+
|  ê²½ë¡œ ë° ìƒíƒœ ìˆ˜ì‹  ëŒ€ê¸° |--------->|   ì†ë„ ê³„íš        |
+-------------------------+         +-------------------+
                                             |
                                             v
                                   +--------------------+
                                   |  ìˆœìˆ˜ ì¶”ì¢… ì•Œê³ ë¦¬ì¦˜ |
                                   |     ì‹¤í–‰           |
                                   +--------------------+
                                             |
                                             v
                                   +-------------------+
                                   |    PID ì œì–´ ì‹¤í–‰   |
                                   +-------------------+
                                             |
                                             v
                                   +-------------------+
                                   |   ì œì–´ ëª…ë ¹ ë°œí–‰   |
                                   +-------------------+
                                             |
                                             v
                                   +-------------------+
                                   |   ë£¨í”„ ë°˜ë³µ        |
                                   +-------------------+
                                             |
                                             v
                                   +-------------------+
                                   |   í”„ë¡œê·¸ë¨ ì¢…ë£Œ    |
                                   +-------------------+

```

##### ì†ë„ ê³„íš ë£¨í”„
```
+---------------------+
|  ì†ë„ ê³„íš ë£¨í”„      |
+---------------------+
          |
          v
+---------------------+
|  ì „ë°© ì£¼ì‹œ ê±°ë¦¬ ê³„íš |
+---------------------+
          |
          v
+---------------------+
|   ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš|
+---------------------+
          |
          v
+---------------------+
|   ìµœì¢… ì†ë„ ê³„íš     |
+---------------------+

```

##### Pure Persuit ì•Œê³ ë¦¬ì¦˜ ë£¨í”„
```
+---------------------+
|  ìˆœìˆ˜ ì¶”ì¢… ì•Œê³ ë¦¬ì¦˜  |
|      ë£¨í”„           |
+---------------------+
          |
          v
+---------------------+
|  í˜„ì¬ ìœ„ì¹˜ ë° ë°©í–¥   |
|      ìˆ˜ì‹            |
+---------------------+
          |
          v
+----------------------+
|    ìˆœìˆ˜ ì¶”ì¢… ì•Œê³ ë¦¬ì¦˜ |
|      ì‹¤í–‰            |
+----------------------+

```

##### PID ì œì–´ ë£¨í”„
```
+---------------------+
|  PID ì œì–´ ë£¨í”„       |
+---------------------+
          |
          v
+----------------------+
|ëª©í‘œ ì†ë„ ë° í˜„ì¬ ì†ë„ |
|      ìˆ˜ì‹             |
+----------------------+
          |
          v
+---------------------+
|   PID ì œì–´ ì‹¤í–‰      |
+---------------------+
```

## 5. acc.py

#### 5-1) ì½”ë“œ (ë¯¸ì™„ì„±)

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow,atan2
from geometry_msgs.msg import Point,PoseWithCovarianceStamped
from nav_msgs.msg import Odometry,Path
from morai_msgs.msg import CtrlCmd,EgoVehicleStatus,ObjectStatusList
import numpy as np
import tf
from tf.transformations import euler_from_quaternion,quaternion_from_euler

# acc ëŠ” ì°¨ëŸ‰ì˜ Adaptive Cruise Control ì˜ˆì œì…ë‹ˆë‹¤.
# ì°¨ëŸ‰ ê²½ë¡œìƒì˜ ì¥ì• ë¬¼ì„ íƒìƒ‰í•˜ì—¬ íƒìƒ‰ëœ ì°¨ëŸ‰ê³¼ì˜ ì†ë„ ì°¨ì´ë¥¼ ê³„ì‚°í•˜ì—¬ Cruise Control ì„ ì§„í–‰í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. subscriber, publisher ì„ ì–¸
# 2. ì†ë„ ë¹„ë¡€ Look Ahead Distance ê°’ ì„¤ì •
# 3. ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
# 4. Steering ê°ë„ ê³„ì‚°
# 5. PID ì œì–´ ìƒì„±
# 6. ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
# 7. ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
# 8. ê²½ë¡œìƒì˜ ì¥ì• ë¬¼ ìœ ë¬´ í™•ì¸ (ì°¨ëŸ‰, ì‚¬ëŒ, ì •ì§€ì„  ì‹ í˜¸)
# 9. ì¥ì• ë¬¼ê³¼ì˜ ì†ë„ì™€ ê±°ë¦¬ ì°¨ì´ë¥¼ ì´ìš©í•˜ì—¬ ACC ë¥¼ ì§„í–‰ ëª©í‘œ ì†ë„ë¥¼ ì„¤ì •
# 10. ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish

# (0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹

# acc ëŠ” ì°¨ëŸ‰ì˜ Adaptive Cruise Control ë™ì‘ì„ ìœ„í•œ ì˜ˆì œì…ë‹ˆë‹¤.
# advanced Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ê°•í™” ê¹Œì§€ëŠ” ì°¨ëŸ‰ì˜ ì œì–´ì— ëŒ€í•´ì„œ ì‘ì„± ë˜ì—ˆë‹¤ë©´ 
# acc ëŠ” Ego ì°¨ëŸ‰ ì „ë°©ì— ìˆëŠ” NPC ì°¨ëŸ‰ì„ ì¸ì‹ í•œ ë’¤ NPC ì°¨ëŸ‰ì— ì¶©ëŒí•˜ì§€ ì•Šê³ 
# ì¼ì •í•œ ê°„ê²©ì„ ìœ ì§€í•˜ë©° ì£¼í–‰ í•˜ë„ë¡ í•˜ëŠ” Car-Following ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.
# ì „ë°© NPC ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ì¢Œí‘œì™€ ì†ë„ ê°’ ì´ìš© Ego ì°¨ëŸ‰ê³¼ì˜ ìƒëŒ€ ê±°ë¦¬ì™€ ìƒëŒ€ ì†ë„ë¥¼ ì¸¡ì •í•©ë‹ˆë‹¤.
# ì¸¡ì • ëœ ìƒëŒ€ ê±°ë¦¬ ìƒëŒ€ ì†ë„ ê°’ì„ ì´ìš©í•˜ì—¬ Ego ì°¨ëŸ‰ì˜ Target ì†ë„ë¥¼ ê²°ì •í•˜ê³  ì£¼í–‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.


class pure_pursuit :
    def __init__(self):
        rospy.init_node('pure_pursuit', anonymous=True)

        # (1) subscriber, publisher ì„ ì–¸
        
        # Local/Gloabl Path ì™€ Odometry Ego Status ë°ì´í„°ë¥¼ ìˆ˜ì‹  í•  Subscriber ë¥¼ ë§Œë“¤ê³  
        # CtrlCmd ë¥¼ ì‹œë®¬ë ˆì´í„°ë¡œ ì „ì†¡ í•  publisher ë³€ìˆ˜ë¥¼ ë§Œë“ ë‹¤.
        # CtrlCmd ì€ 1ì¥ì„ ì°¸ê³  í•œë‹¤.
        # Ego topic ë°ì´í„°ëŠ” ì°¨ëŸ‰ì˜ í˜„ì¬ ì†ë„ë¥¼ ì•Œê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        # Gloabl Path ë°ì´í„°ëŠ” ê²½ë¡œì˜ ê³¡ë¥ ì„ ì´ìš©í•œ ì†ë„ ê³„íšì„ ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        rospy.Subscriber("/global_path", Path, self.global_path_callback)
        rospy.Subscriber("local_path", Path, self.path_callback )
        rospy.Subscriber("/odom", Odometry, self.odom_callback)
        rospy.Subscriber( 'Ego_topic' , EgoVehicleStatus , self.status_callback)
        rospy.Subscriber("/Object_topic" , ObjectStatusList, self.object_info_callback)
        self.ctrl_cmd_pub = rospy.Publisher("/ctrl_cmd", CtrlCmd, queue_size=10)

        

        self.ctrl_cmd_msg = CtrlCmd()
        self.ctrl_cmd_msg.longlCmdType = 1

        self.is_path = False
        self.is_odom = False
        self.is_status = False
        self.is_global_path = False
        self.is_look_forward_point = False

        self.forward_point = Point()
        self.current_postion = Point()

        self.vehicle_length = 2.6
        self.lfd = 8
        self.min_lfd=5
        self.max_lfd=30
        self.lfd_gain = 0.78
        self.target_velocity = 40

        self.pid = pidControl()
        self.adaptive_cruise_control = AdaptiveCruiseControl(velocity_gain = 0.5, distance_gain = 1, time_gap = 0.8, vehicle_length = 2.7)
        self.vel_planning = velocityPlanning(self.target_velocity/3.6, 0.15)

        while True:
            if self.is_global_path == True:
                self.velocity_list = self.vel_planning.curvedBaseVelocity(self.global_path, 50)
                print("1")
                break
            else:
                rospy.loginfo('Waiting global path data')

        rate = rospy.Rate(30) # 30hz
        while not rospy.is_shutdown():

            if self.is_path == True and self.is_odom == True and self.is_status == True:

                # global_obj,local_obj
                result = self.calc_vaild_obj([self.current_postion.x,self.current_postion.y,self.vehicle_yaw],self.object_data)
                
                global_npc_info = result[0] 
                local_npc_info = result[1] 
                global_ped_info = result[2] 
                local_ped_info = result[3] 
                global_obs_info = result[4] 
                local_obs_info = result[5] 
                
                self.current_waypoint = self.get_current_waypoint([self.current_postion.x,self.current_postion.y],self.global_path)
                self.target_velocity = self.velocity_list[self.current_waypoint]*3.6

                steering = self.calc_pure_pursuit()
                if self.is_look_forward_point :
                    self.ctrl_cmd_msg.steering = steering
                else : 
                    rospy.loginfo("no found forward point")
                    self.ctrl_cmd_msg.steering=0.0

                self.adaptive_cruise_control.check_object(self.path ,global_npc_info, local_npc_info
                                                                    ,global_ped_info, local_ped_info
                                                                    ,global_obs_info, local_obs_info)
                self.target_velocity = self.adaptive_cruise_control.get_target_velocity(local_npc_info, local_ped_info, local_obs_info,
                                                                                                        self.status_msg.velocity.x, self.target_velocity/3.6)

                output = self.pid.pid(self.target_velocity,self.status_msg.velocity.x*3.6)

                if output > 0.0:
                    self.ctrl_cmd_msg.accel = output
                    self.ctrl_cmd_msg.brake = 0.0
                else:
                    self.ctrl_cmd_msg.accel = 0.0
                    self.ctrl_cmd_msg.brake = -output

                # (10) ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish
            
                # ì œì–´ì…ë ¥ ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.ctrl_cmd_pub.publish(self.ctrl_cmd_msg)

            rate.sleep()

    def path_callback(self,msg):
        self.is_path=True
        self.path=msg  

    def odom_callback(self,msg):
        self.is_odom=True
        odom_quaternion=(msg.pose.pose.orientation.x,msg.pose.pose.orientation.y,msg.pose.pose.orientation.z,msg.pose.pose.orientation.w)
        _,_,self.vehicle_yaw=euler_from_quaternion(odom_quaternion)
        self.current_postion.x=msg.pose.pose.position.x
        self.current_postion.y=msg.pose.pose.position.y

    def status_callback(self,msg): ## Vehicl Status Subscriber 
        self.is_status=True
        self.status_msg=msg    
        
    def global_path_callback(self,msg):
        self.global_path = msg
        self.is_global_path = True

    def object_info_callback(self,data): ## Object information Subscriber
        self.is_object_info = True
        self.object_data = data 
        print("Object Hi!")

    def get_current_waypoint(self,ego_status,global_path):
        min_dist = float('inf')        
        currnet_waypoint = -1     

        ego_pose_x = ego_status[0]
        ego_pose_y = ego_status[1]

        for i,pose in enumerate(global_path.poses):
            dx = ego_pose_x - pose.pose.position.x
            dy = ego_pose_y - pose.pose.position.y

            dist = sqrt(pow(dx,2)+pow(dy,2))
            if min_dist > dist :
                min_dist = dist
                currnet_waypoint = i
        return currnet_waypoint

    def calc_vaild_obj(self,status_msg,object_data):
        
        self.all_object = object_data        
        ego_pose_x = status_msg[0]
        ego_pose_y = status_msg[1]
        ego_heading = status_msg[2]
        
        global_npc_info = []
        local_npc_info  = []
        global_ped_info = []
        local_ped_info  = []
        global_obs_info = []
        local_obs_info  = []

        num_of_object = self.all_object.num_of_npcs + self.all_object.num_of_obstacle + self.all_object.num_of_pedestrian        
        if num_of_object > 0:

            #translation
            tmp_theta=ego_heading
            tmp_translation=[ego_pose_x, ego_pose_y]
            tmp_t=np.array([[cos(tmp_theta), -sin(tmp_theta), tmp_translation[0]],
                            [sin(tmp_theta),  cos(tmp_theta), tmp_translation[1]],
                            [0             ,               0,                  1]])
            tmp_det_t=np.array([[tmp_t[0][0], tmp_t[1][0], -(tmp_t[0][0] * tmp_translation[0] + tmp_t[1][0]*tmp_translation[1])],
                                [tmp_t[0][1], tmp_t[1][1], -(tmp_t[0][1] * tmp_translation[0] + tmp_t[1][1]*tmp_translation[1])],
                                [0,0,1]])

            #npc vehicle ranslation        
            for npc_list in self.all_object.npc_list:
                global_result=np.array([[npc_list.position.x],[npc_list.position.y],[1]])
                local_result=tmp_det_t.dot(global_result)
                if local_result[0][0]> 0 :        
                    global_npc_info.append([npc_list.type,npc_list.position.x,npc_list.position.y,npc_list.velocity.x])
                    local_npc_info.append([npc_list.type,local_result[0][0],local_result[1][0],npc_list.velocity.x])

            #ped translation
            for ped_list in self.all_object.pedestrian_list:
                global_result=np.array([[ped_list.position.x],[ped_list.position.y],[1]])
                local_result=tmp_det_t.dot(global_result)
                if local_result[0][0]> 0 :
                    global_ped_info.append([ped_list.type,ped_list.position.x,ped_list.position.y,ped_list.velocity.x])
                    local_ped_info.append([ped_list.type,local_result[0][0],local_result[1][0],ped_list.velocity.x])

            #obs translation
            for obs_list in self.all_object.obstacle_list:
                global_result=np.array([[obs_list.position.x],[obs_list.position.y],[1]])
                local_result=tmp_det_t.dot(global_result)
                if local_result[0][0]> 0 :
                    global_obs_info.append([obs_list.type,obs_list.position.x,obs_list.position.y,obs_list.velocity.x])
                    local_obs_info.append([obs_list.type,local_result[0][0],local_result[1][0],obs_list.velocity.x])
                
        return global_npc_info, local_npc_info, global_ped_info, local_ped_info, global_obs_info, local_obs_info

    def calc_pure_pursuit(self,):

        # (2) ì†ë„ ë¹„ë¡€ Look Ahead Distance ê°’ ì„¤ì •
        
        # ì°¨ëŸ‰ ì†ë„ì— ë¹„ë¡€í•˜ì—¬ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°€ ë³€í•˜ëŠ” ìˆ˜ì‹ì„ êµ¬í˜„ í•©ë‹ˆë‹¤.
        # ì´ë•Œ 'self.lfd' ê°’ì€ ìµœì†Œì™€ ìµœëŒ€ ê°’ì„ ë„˜ì–´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤.
        # "self.min_lfd","self.max_lfd", "self.lfd_gain" ì„ ë¯¸ë¦¬ ì •ì˜í•©ë‹ˆë‹¤.
        # ìµœì†Œ ìµœëŒ€ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°’ê³¼ ì†ë„ì— ë¹„ë¡€í•œ lfd_gain ê°’ì„ ì§ì ‘ ë³€ê²½í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        # ì´ˆê¸° ì •ì˜í•œ ë³€ìˆ˜ ë“¤ì˜ ê°’ì„ ë³€ê²½í•˜ë©° ì†ë„ì— ë¹„ë¡€í•´ì„œ ì „ë°©ì£¼ì‹œê±°ë¦¬ ê°€ ë³€í•˜ëŠ” advanced_purepursuit ì˜ˆì œë¥¼ ì™„ì„±í•˜ì„¸ìš”.
        
        self.lfd = self.lfd_gain * self.status_msg.velocity.x
        self.lfd = max(self.min_lfd, min(self.max_lfd, self.lfd))  # ìµœì†Œê°’ê³¼ ìµœëŒ€ê°’ ì‚¬ì´ì˜ ê°’ìœ¼ë¡œ ì¡°ì •
        rospy.loginfo(self.lfd)

        
        
        vehicle_position=self.current_postion
        self.is_look_forward_point= False

        translation = [vehicle_position.x, vehicle_position.y]

        # (3) ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
        
        # Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰ í•˜ê¸° ìœ„í•´ì„œ ì°¨ëŸ‰ ê¸°ì¤€ì˜ ì¢Œí‘œê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ í˜„ì¬ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œê³„ë¡œ ì¢Œí‘œ ë³€í™˜ì´ í•„ìš”í•©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì‘ì„±í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë³€í™˜ í›„ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì´ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•˜ê²Œ ë©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì´ìš©í•´ Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë°”ê¾¸ëŠ” ë°˜ë³µ ë¬¸ì„ ì‘ì„± í•œ ë’¤
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ê³„ì‚°í•˜ëŠ” ë¡œì§ì„ ì‘ì„± í•˜ì„¸ìš”.
        
        trans_matrix = np.array([[cos(self.vehicle_yaw),-sin(self.vehicle_yaw) ,0],
                                [sin(self.vehicle_yaw),cos(self.vehicle_yaw),0],
                                [0,0,1]])

        det_trans_matrix = np.linalg.inv(trans_matrix)

        for num,i in enumerate(self.path.poses) :
            path_point = i.pose.position

            global_path_point = [path_point.x - vehicle_position.x, path_point.y - vehicle_position.y, 1]
            local_path_point = det_trans_matrix.dot(global_path_point)    
            #print("g :", global_path_point)
            #print("l :", local_path_point)
            # if local_path_point[0]>0 :
            #     dis = sqrt(local_path_point[0]**2 + local_path_point[1]**2)
            #     if dis >= self.lfd :
            #         self.forward_point = local_path_point
            #         self.is_look_forward_point = True
            #         break
            if local_path_point[0] > 0:
                # ê°ë„ë¥¼ ê³„ì‚°í•˜ì—¬ ì •ë©´ì— ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
                angle_to_point = atan2(local_path_point[1], local_path_point[0])
                if abs(angle_to_point) < pi / 2:  # ì •ë©´ì— ìˆëŠ” ê²½ìš°ì—ë§Œ
                    dis = sqrt(local_path_point[0] ** 2 + local_path_point[1] ** 2)
                    if dis >= self.lfd:
                        self.forward_point = local_path_point
                        self.is_look_forward_point = True
                        break
        
        # (4) Steering ê°ë„ ê³„ì‚°
        
        # ì œì–´ ì…ë ¥ì„ ìœ„í•œ Steering ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # theta ëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ì¢Œí‘œì˜ ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # Steering ê°ë„ëŠ” Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì˜ ê°ë„ ê³„ì‚° ìˆ˜ì‹ì„ ì ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        theta = atan2(self.forward_point[1], self.forward_point[0])
        steering = atan2( ( 2 * self.vehicle_length * sin(theta)), sqrt(self.forward_point[0]**2 + self.forward_point[1]**2))

        return steering

class pidControl:
    def __init__(self):
        self.p_gain = 0.3
        self.i_gain = 0.00
        self.d_gain = 0.03
        self.prev_error = 0
        self.i_control = 0
        self.controlTime = 0.02

    def pid(self,target_vel, current_vel):
        error = target_vel - current_vel

        # (5) PID ì œì–´ ìƒì„±
        
        # ì¢…ë°©í–¥ ì œì–´ë¥¼ ìœ„í•œ PID ì œì–´ê¸°ëŠ” í˜„ì¬ ì†ë„ì™€ ëª©í‘œ ì†ë„ ê°„ ì°¨ì´ë¥¼ ì¸¡ì •í•˜ì—¬ Accel/Brake ê°’ì„ ê²°ì • í•©ë‹ˆë‹¤.
        # ê° PID ì œì–´ë¥¼ ìœ„í•œ Gain ê°’ì€ "class pidContorl" ì— ì •ì˜ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
        # ê° PID Gain ê°’ì„ ì§ì ‘ íŠœë‹í•˜ê³  ì•„ë˜ ìˆ˜ì‹ì„ ì±„ì›Œ ë„£ì–´ P I D ì œì–´ê¸°ë¥¼ ì™„ì„±í•˜ì„¸ìš”.
        p_control = self.p_gain * error
        self.i_control += self.i_gain * error * self.controlTime
        d_control = self.d_gain * ((error - self.prev_error) / self.controlTime)
        output = p_control + self.i_control + d_control
        self.prev_error = error

        return output

class velocityPlanning:
    def __init__ (self,car_max_speed, road_friciton):
        self.car_max_speed = car_max_speed
        self.road_friction = road_friciton

    def curvedBaseVelocity(self, gloabl_path, point_num):
        out_vel_plan = []

        for i in range(0,point_num):
            out_vel_plan.append(self.car_max_speed)

        for i in range(point_num, len(gloabl_path.poses) - point_num):
            x_list = []
            y_list = []
            for box in range(-point_num, point_num):
                x = gloabl_path.poses[i+box].pose.position.x
                y = gloabl_path.poses[i+box].pose.position.y
                x_list.append([-2*x, -2*y ,1])
                y_list.append((-x*x) - (y*y))

            # (6) ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
            
            # ë„ë¡œì˜ ê³¡ë¥  ë°˜ê²½ì„ ê³„ì‚°í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì…ë‹ˆë‹¤.
            # Path ë°ì´í„°ì˜ ì¢Œí‘œë¥¼ ì´ìš©í•´ì„œ ê³¡ì„ ì˜ ê³¡ë¥ ì„ êµ¬í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì„ ì‘ì„±í•©ë‹ˆë‹¤.
            # ì›ì˜ ì¢Œí‘œë¥¼ êµ¬í•˜ëŠ” í–‰ë ¬ ê³„ì‚°ì‹, ìµœì†Œ ììŠ¹ë²•ì„ ì´ìš©í•˜ëŠ” ë°©ì‹ ë“± ê³¡ë¥  ë°˜ì§€ë¦„ì„ êµ¬í•˜ê¸° ìœ„í•œ ì‹ì„ ì ìš© í•©ë‹ˆë‹¤.
            # ì ìš©í•œ ìˆ˜ì‹ì„ í†µí•´ ê³¡ë¥  ë°˜ì§€ë¦„ "r" ì„ ê³„ì‚°í•©ë‹ˆë‹¤.

            A = np.array(x_list)
            B = np.array(y_list)
            result = np.linalg.lstsq(A, B, rcond=None)

            if len(result[0]) == 0:
                continue

            r = sqrt(result[0][0] ** 2 + result[0][1] ** 2)  # ê³¡ë¥  ë°˜ê²½ ê³„ì‚°
            gravityAcc = 9.8

            # (7) ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
            
            # ê³„ì‚° í•œ ê³¡ë¥  ë°˜ê²½ì„ ì´ìš©í•˜ì—¬ ìµœê³  ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            # í‰í‰í•œ ë„ë¡œì¸ ê²½ìš° ìµœëŒ€ ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. 
            # ê³¡ë¥  ë°˜ê²½ x ì¤‘ë ¥ê°€ì†ë„ x ë„ë¡œì˜ ë§ˆì°° ê³„ìˆ˜ ê³„ì‚° ê°’ì˜ ì œê³±ê·¼ì´ ë©ë‹ˆë‹¤.
            v_max = sqrt(r * self.road_friction * gravityAcc)  # ìµœëŒ€ ì†ë„ ê³„íš
            print("r : " + str(r))
            print("friction : " + str(self.road_friction))
            print("gravityAcc : " + str(gravityAcc))
            print("v_max: " + str(v_max))
            print("\n")
            
            if v_max > self.car_max_speed:
                v_max = self.car_max_speed
            out_vel_plan.append(v_max)

        for i in range(len(gloabl_path.poses) - point_num, len(gloabl_path.poses)-10):
            out_vel_plan.append(30)

        for i in range(len(gloabl_path.poses) - 10, len(gloabl_path.poses)):
            out_vel_plan.append(0)

        return out_vel_plan

class AdaptiveCruiseControl:
    def __init__(self, velocity_gain, distance_gain, time_gap, vehicle_length):
        self.npc_vehicle=[False,0]
        self.object=[False,0]
        self.Person=[False,0]
        self.velocity_gain = velocity_gain
        self.distance_gain = distance_gain
        self.time_gap = time_gap
        self.vehicle_length = vehicle_length

        self.object_type = None
        self.object_distance = 0
        self.object_velocity = 0

    def check_object(self,ref_path, global_npc_info, local_npc_info, 
                                    global_ped_info, local_ped_info, 
                                    global_obs_info, local_obs_info):
        #TODO: (8) ê²½ë¡œìƒì˜ ì¥ì• ë¬¼ ìœ ë¬´ í™•ì¸ (ì°¨ëŸ‰, ì‚¬ëŒ, ì •ì§€ì„  ì‹ í˜¸)
        '''
        # ì£¼í–‰ ê²½ë¡œ ìƒì˜ ì¥ì• ë¬¼ì˜ ìœ ë¬´ë¥¼ íŒŒì•…í•©ë‹ˆë‹¤.
        # ì¥ì• ë¬¼ì´ í•œê°œ ì´ìƒ ìˆë‹¤ë©´ self.object ë³€ìˆ˜ì˜ ì²«ë²ˆì§¸ ê°’ì„ True ë¡œ ë‘¡ë‹ˆë‹¤.
        # ì¥ì• ë¬¼ì˜ ëŒ€í•œ ì •ë³´ëŠ” List í˜•ì‹ìœ¼ë¡œ self.object ë³€ìˆ˜ì˜ ë‘ë²ˆì§¸ ê°’ìœ¼ë¡œ ë‘¡ë‹ˆë‹¤.
        # ì¥ì• ë¬¼ì˜ ìœ ë¬´ íŒë‹¨ì€ ì£¼í–‰ í•  ê²½ë¡œì—ì„œ ì–¼ë§ˆë‚˜ ë–¨ì–´ì ¸ ìˆëŠ”ì§€ë¥¼ ë³´ê³  íŒë‹¨ í•©ë‹ˆë‹¤.
        # ì•„ë˜ ì˜ˆì œëŠ” ì£¼í–‰ ê²½ë¡œì—ì„œ Object ê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ íŒŒì•…í•˜ì—¬ 
        # ê²½ë¡œë¥¼ ê¸°ì¤€ìœ¼ë¡œ 2.5 m ì•ˆìª½ì— ìˆë‹¤ë©´ ì£¼í–‰ ê²½ë¡œ ë‚´ ì¥ì• ë¬¼ì´ ìˆë‹¤ê³  íŒë‹¨ í•©ë‹ˆë‹¤.
        # ì£¼í–‰ ê²½ë¡œ ìƒ ì¥ì• ë¬¼ì´ ì—¬ëŸ¬ê²Œ ìˆëŠ” ê²½ìš° ê°€ì¥ ê°€ê¹Œì´ ìˆëŠ” ì¥ì• ë¬¼ ì •ë³´ë¥¼ ê°€ì§€ë„ë¡ í•©ë‹ˆë‹¤.

        '''

        '''
        # ì£¼í–‰ ê²½ë¡œ ìƒ ë³´í–‰ì ìœ ë¬´ íŒŒì•…
        min_rel_distance=float('inf')
        if len(global_ped_info) > 0 :        
            for i in range(len(global_ped_info)):
                for path in ref_path.poses :      
                    if global_ped_info[i][0] == 0 : # type=0 [pedestrian]                    
                        dis = 
                        if dis<2.35:                            
                            rel_distance = 
                            if rel_distance < min_rel_distance:
                                min_rel_distance = 
                                self.Person=[True,i]

        '''

        '''
        # ì£¼í–‰ ê²½ë¡œ ìƒ NPC ì°¨ëŸ‰ ìœ ë¬´ íŒŒì•…
        if len(global_npc_info) > 0 :            
            for i in range(len(global_npc_info)):
                for path in ref_path.poses :      
                    if global_npc_info[i][0] == 1 : # type=1 [npc_vehicle] 
                        dis = 
                        if dis<2.35:
                            rel_distance =        
                            if rel_distance < min_rel_distance:
                                min_rel_distance = 
                                self.npc_vehicle=[True,i]
        
        '''

        '''
        # ì£¼í–‰ ê²½ë¡œ ìƒ Obstacle ìœ ë¬´ íŒŒì•…
        # acc ì˜ˆì œëŠ” ì£¼í–‰ ì¤‘ ì „ë°©ì— ì°¨ëŸ‰ì— ì†ë„ì— ë§ì¶° ì›€ì§ì´ë„ë¡ í•˜ëŠ” Cruise Control
        # ì˜ˆì œ ì´ê¸° ë•Œë¬¸ì— ì •ì  ì¥ì• ë¬¼(Obstacle) ì˜ ì •ë³´ëŠ” ë°›ì§€ ì•ŠëŠ”ê²Œ ì¢‹ìŠµë‹ˆë‹¤.
        # ì •ì  ì¥ì• ë¬¼ì€ ì›€ì§ì´ì§€ ì•Šê¸° ë•Œë¬¸ì— Cruise Control ì•Œê³ ë¦¬ì¦˜ ìƒ
        # ì •ì  ì¥ì• ë¬¼ì„ ë§Œë‚˜ê²Œ ë˜ë©´ ì†ë„ê°€ 0ì¸ ì •ì  ì¥ì• ë¬¼ ë°”ë¡œ ë’¤ì— ì •ì§€í•˜ê²Œ ë©ë‹ˆë‹¤.
        if len(global_obs_info) > 0 :            
            for i in range(len(global_obs_info)):
                for path in ref_path.poses :      
                    if global_obs_info[i][0] == 2 : # type=1 [obstacle] 
                        dis = 
                        if dis<2.35:
                            rel_distance=                
                            if rel_distance < min_rel_distance:
                                min_rel_distance = 
                                # self.object=[True,i] 
        
        '''

    def get_target_velocity(self, local_npc_info, local_ped_info, local_obs_info, ego_vel, target_vel): 

        
        # (9) ì¥ì• ë¬¼ê³¼ì˜ ì†ë„ì™€ ê±°ë¦¬ ì°¨ì´ë¥¼ ì´ìš©í•˜ì—¬ ACC ë¥¼ ì§„í–‰ ëª©í‘œ ì†ë„ë¥¼ ì„¤ì •
        out_vel =  target_vel
        default_space = 8
        time_gap = self.time_gap
        v_gain = self.velocity_gain
        x_errgain = self.distance_gain

        if self.npc_vehicle[0] and len(local_npc_info) != 0: #ACC ON_vehicle   
            print("ACC ON NPC_Vehicle")         
            front_vehicle = [local_npc_info[self.npc_vehicle[1]][1], local_npc_info[self.npc_vehicle[1]][2], local_npc_info[self.npc_vehicle[1]][3]]
            
            dis_safe = ego_vel * time_gap + default_space
            dis_rel = sqrt(pow(front_vehicle[0],2) + pow(front_vehicle[1],2))            
            vel_rel=((front_vehicle[2] / 3.6) - ego_vel)                        
            acceleration = vel_rel * v_gain - x_errgain * (dis_safe - dis_rel)

            out_vel = ego_vel + acceleration      

        if self.Person[0] and len(local_ped_info) != 0: #ACC ON_Pedestrian
            print("ACC ON Pedestrian")
            Pedestrian = [local_ped_info[self.Person[1]][1], local_ped_info[self.Person[1]][2], local_ped_info[self.Person[1]][3]]
            
            dis_safe = ego_vel* time_gap + default_space
            dis_rel = sqrt(pow(Pedestrian[0],2) + pow(Pedestrian[1],2))            
            vel_rel = (Pedestrian[2] - ego_vel)              
            acceleration = vel_rel * v_gain - x_errgain * (dis_safe - dis_rel)    

            out_vel = ego_vel + acceleration
   
        if self.object[0] and len(local_obs_info) != 0: #ACC ON_obstacle     
            print("ACC ON Obstacle")                    
            Obstacle = [local_obs_info[self.object[1]][1], local_obs_info[self.object[1]][2], local_obs_info[self.object[1]][3]]
            
            dis_safe = ego_vel* time_gap + default_space
            dis_rel = sqrt(pow(Obstacle[0],2) + pow(Obstacle[1],2))            
            vel_rel = (Obstacle[2] - ego_vel)
            acceleration = vel_rel * v_gain - x_errgain * (dis_safe - dis_rel)    

            out_vel = ego_vel + acceleration           
        print("HI OBJ VEL")
        return out_vel * 3.6


if __name__ == '__main__':
    try:
        test_track=pure_pursuit()
    except rospy.ROSInterruptException:
        pass

```

<br>

#### 5-2) ì½”ë“œ (0315 - ì—ëŸ¬ ë‚¨)

(ë³´í–‰ì ì•ì—ì„œ ë©ˆì¶”ëŠ”ê±´ í™•ì¸ë˜ëŠ”ë° ê·¸ ë‹¤ìŒì— ì—ëŸ¬ë‚¨)
##### ì—ëŸ¬ ë‚´ìš© (0318ì— í•´ê²°í•´ì•¼í•¨)
```
Traceback (most recent call last):
  File "/home/chohj0816/catkin_ws/src/mobility-autodriving-skeleton/ssafy_ad/ssafy_2/scripts/acc.py", line 650, in <module>
    test_track=pure_pursuit()
  File "/home/chohj0816/catkin_ws/src/mobility-autodriving-skeleton/ssafy_ad/ssafy_2/scripts/acc.py", line 120, in __init__
    self.status_msg.velocity.x, self.target_velocity/3.6)
  File "/home/chohj0816/catkin_ws/src/mobility-autodriving-skeleton/ssafy_ad/ssafy_2/scripts/acc.py", line 625, in get_target_velocity
    Pedestrian = [local_ped_info[self.Person[1]][1], local_ped_info[self.Person[1]][2], local_ped_info[self.Person[1]][3]]
IndexError: list index out of range
Object Hi!
```


```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import rospy
import rospkg
from math import cos,sin,pi,sqrt,pow,atan2
from geometry_msgs.msg import Point,PoseWithCovarianceStamped
from nav_msgs.msg import Odometry,Path
from morai_msgs.msg import CtrlCmd,EgoVehicleStatus,ObjectStatusList
import numpy as np
import tf
from tf.transformations import euler_from_quaternion,quaternion_from_euler

# acc ëŠ” ì°¨ëŸ‰ì˜ Adaptive Cruise Control ì˜ˆì œì…ë‹ˆë‹¤.
# ì°¨ëŸ‰ ê²½ë¡œìƒì˜ ì¥ì• ë¬¼ì„ íƒìƒ‰í•˜ì—¬ íƒìƒ‰ëœ ì°¨ëŸ‰ê³¼ì˜ ì†ë„ ì°¨ì´ë¥¼ ê³„ì‚°í•˜ì—¬ Cruise Control ì„ ì§„í–‰í•©ë‹ˆë‹¤.

# ë…¸ë“œ ì‹¤í–‰ ìˆœì„œ 
# 0. í•„ìˆ˜ í•™ìŠµ ì§€ì‹
# 1. subscriber, publisher ì„ ì–¸
# 2. ì†ë„ ë¹„ë¡€ Look Ahead Distance ê°’ ì„¤ì •
# 3. ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
# 4. Steering ê°ë„ ê³„ì‚°
# 5. PID ì œì–´ ìƒì„±
# 6. ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
# 7. ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
# 8. ê²½ë¡œìƒì˜ ì¥ì• ë¬¼ ìœ ë¬´ í™•ì¸ (ì°¨ëŸ‰, ì‚¬ëŒ, ì •ì§€ì„  ì‹ í˜¸)
# 9. ì¥ì• ë¬¼ê³¼ì˜ ì†ë„ì™€ ê±°ë¦¬ ì°¨ì´ë¥¼ ì´ìš©í•˜ì—¬ ACC ë¥¼ ì§„í–‰ ëª©í‘œ ì†ë„ë¥¼ ì„¤ì •
# 10. ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish

# (0) í•„ìˆ˜ í•™ìŠµ ì§€ì‹

# acc ëŠ” ì°¨ëŸ‰ì˜ Adaptive Cruise Control ë™ì‘ì„ ìœ„í•œ ì˜ˆì œì…ë‹ˆë‹¤.
# advanced Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ê°•í™” ê¹Œì§€ëŠ” ì°¨ëŸ‰ì˜ ì œì–´ì— ëŒ€í•´ì„œ ì‘ì„± ë˜ì—ˆë‹¤ë©´ 
# acc ëŠ” Ego ì°¨ëŸ‰ ì „ë°©ì— ìˆëŠ” NPC ì°¨ëŸ‰ì„ ì¸ì‹ í•œ ë’¤ NPC ì°¨ëŸ‰ì— ì¶©ëŒí•˜ì§€ ì•Šê³ 
# ì¼ì •í•œ ê°„ê²©ì„ ìœ ì§€í•˜ë©° ì£¼í–‰ í•˜ë„ë¡ í•˜ëŠ” Car-Following ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.
# ì „ë°© NPC ì°¨ëŸ‰ì˜ ìœ„ì¹˜ ì¢Œí‘œì™€ ì†ë„ ê°’ ì´ìš© Ego ì°¨ëŸ‰ê³¼ì˜ ìƒëŒ€ ê±°ë¦¬ì™€ ìƒëŒ€ ì†ë„ë¥¼ ì¸¡ì •í•©ë‹ˆë‹¤.
# ì¸¡ì • ëœ ìƒëŒ€ ê±°ë¦¬ ìƒëŒ€ ì†ë„ ê°’ì„ ì´ìš©í•˜ì—¬ Ego ì°¨ëŸ‰ì˜ Target ì†ë„ë¥¼ ê²°ì •í•˜ê³  ì£¼í–‰í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.


class pure_pursuit :
    def __init__(self):
        rospy.init_node('pure_pursuit', anonymous=True)

        # (1) subscriber, publisher ì„ ì–¸
        
        # Local/Gloabl Path ì™€ Odometry Ego Status ë°ì´í„°ë¥¼ ìˆ˜ì‹  í•  Subscriber ë¥¼ ë§Œë“¤ê³  
        # CtrlCmd ë¥¼ ì‹œë®¬ë ˆì´í„°ë¡œ ì „ì†¡ í•  publisher ë³€ìˆ˜ë¥¼ ë§Œë“ ë‹¤.
        # CtrlCmd ì€ 1ì¥ì„ ì°¸ê³  í•œë‹¤.
        # Ego topic ë°ì´í„°ëŠ” ì°¨ëŸ‰ì˜ í˜„ì¬ ì†ë„ë¥¼ ì•Œê¸° ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        # Gloabl Path ë°ì´í„°ëŠ” ê²½ë¡œì˜ ê³¡ë¥ ì„ ì´ìš©í•œ ì†ë„ ê³„íšì„ ìœ„í•´ ì‚¬ìš©í•œë‹¤.
        rospy.Subscriber("/global_path", Path, self.global_path_callback)
        rospy.Subscriber("local_path", Path, self.path_callback )
        rospy.Subscriber("/odom", Odometry, self.odom_callback)
        rospy.Subscriber( 'Ego_topic' , EgoVehicleStatus , self.status_callback)
        rospy.Subscriber("/Object_topic" , ObjectStatusList, self.object_info_callback)
        self.ctrl_cmd_pub = rospy.Publisher("/ctrl_cmd", CtrlCmd, queue_size=10)

        

        self.ctrl_cmd_msg = CtrlCmd()
        self.ctrl_cmd_msg.longlCmdType = 1

        self.is_path = False
        self.is_odom = False
        self.is_status = False
        self.is_global_path = False
        self.is_look_forward_point = False

        self.forward_point = Point()
        self.current_postion = Point()

        self.vehicle_length = 2.6
        self.lfd = 8
        self.min_lfd=5
        self.max_lfd=30
        self.lfd_gain = 0.78
        self.target_velocity = 40

        self.pid = pidControl()
        self.adaptive_cruise_control = AdaptiveCruiseControl(velocity_gain = 0.5, distance_gain = 1, time_gap = 0.8, vehicle_length = 2.7)
        self.vel_planning = velocityPlanning(self.target_velocity/3.6, 0.15)

        while True:
            if self.is_global_path == True:
                self.velocity_list = self.vel_planning.curvedBaseVelocity(self.global_path, 50)
                print("1")
                break
            else:
                rospy.loginfo('Waiting global path data')

        rate = rospy.Rate(30) # 30hz
        while not rospy.is_shutdown():

            if self.is_path == True and self.is_odom == True and self.is_status == True:

                # global_obj,local_obj
                result = self.calc_vaild_obj([self.current_postion.x,self.current_postion.y,self.vehicle_yaw],self.object_data)
                
                global_npc_info = result[0] 
                local_npc_info = result[1] 
                global_ped_info = result[2] 
                local_ped_info = result[3] 
                global_obs_info = result[4] 
                local_obs_info = result[5] 
                
                self.current_waypoint = self.get_current_waypoint([self.current_postion.x,self.current_postion.y],self.global_path)
                self.target_velocity = self.velocity_list[self.current_waypoint]*3.6

                steering = self.calc_pure_pursuit()
                if self.is_look_forward_point :
                    self.ctrl_cmd_msg.steering = steering
                else : 
                    rospy.loginfo("no found forward point")
                    self.ctrl_cmd_msg.steering=0.0

                self.adaptive_cruise_control.check_object(self.path ,global_npc_info, local_npc_info
                                                                    ,global_ped_info, local_ped_info
                                                                    ,global_obs_info, local_obs_info)
                self.target_velocity = self.adaptive_cruise_control.get_target_velocity(local_npc_info, local_ped_info, local_obs_info,
                                                                                                        self.status_msg.velocity.x, self.target_velocity/3.6)

                output = self.pid.pid(self.target_velocity,self.status_msg.velocity.x*3.6)

                if output > 0.0:
                    self.ctrl_cmd_msg.accel = output
                    self.ctrl_cmd_msg.brake = 0.0
                else:
                    self.ctrl_cmd_msg.accel = 0.0
                    self.ctrl_cmd_msg.brake = -output

                # (10) ì œì–´ì…ë ¥ ë©”ì„¸ì§€ Publish
            
                # ì œì–´ì…ë ¥ ë©”ì„¸ì§€ ë¥¼ ì „ì†¡í•˜ëŠ” publisher ë¥¼ ë§Œë“ ë‹¤.
                self.ctrl_cmd_pub.publish(self.ctrl_cmd_msg)

            rate.sleep()

    def path_callback(self,msg):
        self.is_path=True
        self.path=msg  

    def odom_callback(self,msg):
        self.is_odom=True
        odom_quaternion=(msg.pose.pose.orientation.x,msg.pose.pose.orientation.y,msg.pose.pose.orientation.z,msg.pose.pose.orientation.w)
        _,_,self.vehicle_yaw=euler_from_quaternion(odom_quaternion)
        self.current_postion.x=msg.pose.pose.position.x
        self.current_postion.y=msg.pose.pose.position.y

    def status_callback(self,msg): ## Vehicl Status Subscriber 
        self.is_status=True
        self.status_msg=msg    
        
    def global_path_callback(self,msg):
        self.global_path = msg
        self.is_global_path = True

    def object_info_callback(self,data): ## Object information Subscriber
        self.is_object_info = True
        self.object_data = data 
        print("Object Hi!")

    def get_current_waypoint(self,ego_status,global_path):
        min_dist = float('inf')        
        currnet_waypoint = -1     

        ego_pose_x = ego_status[0]
        ego_pose_y = ego_status[1]

        for i,pose in enumerate(global_path.poses):
            dx = ego_pose_x - pose.pose.position.x
            dy = ego_pose_y - pose.pose.position.y

            dist = sqrt(pow(dx,2)+pow(dy,2))
            if min_dist > dist :
                min_dist = dist
                currnet_waypoint = i
        return currnet_waypoint

    def calc_vaild_obj(self,status_msg,object_data):
        
        self.all_object = object_data        
        ego_pose_x = status_msg[0]
        ego_pose_y = status_msg[1]
        ego_heading = status_msg[2]
        
        global_npc_info = []
        local_npc_info  = []
        global_ped_info = []
        local_ped_info  = []
        global_obs_info = []
        local_obs_info  = []

        num_of_object = self.all_object.num_of_npcs + self.all_object.num_of_obstacle + self.all_object.num_of_pedestrian        
        if num_of_object > 0:

            #translation
            tmp_theta=ego_heading
            tmp_translation=[ego_pose_x, ego_pose_y]
            tmp_t=np.array([[cos(tmp_theta), -sin(tmp_theta), tmp_translation[0]],
                            [sin(tmp_theta),  cos(tmp_theta), tmp_translation[1]],
                            [0             ,               0,                  1]])
            tmp_det_t=np.array([[tmp_t[0][0], tmp_t[1][0], -(tmp_t[0][0] * tmp_translation[0] + tmp_t[1][0]*tmp_translation[1])],
                                [tmp_t[0][1], tmp_t[1][1], -(tmp_t[0][1] * tmp_translation[0] + tmp_t[1][1]*tmp_translation[1])],
                                [0,0,1]])

            #npc vehicle ranslation        
            for npc_list in self.all_object.npc_list:
                global_result=np.array([[npc_list.position.x],[npc_list.position.y],[1]])
                local_result=tmp_det_t.dot(global_result)
                if local_result[0][0]> 0 :        
                    global_npc_info.append([npc_list.type,npc_list.position.x,npc_list.position.y,npc_list.velocity.x])
                    local_npc_info.append([npc_list.type,local_result[0][0],local_result[1][0],npc_list.velocity.x])

            #ped translation
            for ped_list in self.all_object.pedestrian_list:
                global_result=np.array([[ped_list.position.x],[ped_list.position.y],[1]])
                local_result=tmp_det_t.dot(global_result)
                if local_result[0][0]> 0 :
                    global_ped_info.append([ped_list.type,ped_list.position.x,ped_list.position.y,ped_list.velocity.x])
                    local_ped_info.append([ped_list.type,local_result[0][0],local_result[1][0],ped_list.velocity.x])

            #obs translation
            for obs_list in self.all_object.obstacle_list:
                global_result=np.array([[obs_list.position.x],[obs_list.position.y],[1]])
                local_result=tmp_det_t.dot(global_result)
                if local_result[0][0]> 0 :
                    global_obs_info.append([obs_list.type,obs_list.position.x,obs_list.position.y,obs_list.velocity.x])
                    local_obs_info.append([obs_list.type,local_result[0][0],local_result[1][0],obs_list.velocity.x])
                
        return global_npc_info, local_npc_info, global_ped_info, local_ped_info, global_obs_info, local_obs_info
    '''
    def calc_pure_pursuit(self,):

        # (2) ì†ë„ ë¹„ë¡€ Look Ahead Distance ê°’ ì„¤ì •
        
        # ì°¨ëŸ‰ ì†ë„ì— ë¹„ë¡€í•˜ì—¬ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°€ ë³€í•˜ëŠ” ìˆ˜ì‹ì„ êµ¬í˜„ í•©ë‹ˆë‹¤.
        # ì´ë•Œ 'self.lfd' ê°’ì€ ìµœì†Œì™€ ìµœëŒ€ ê°’ì„ ë„˜ì–´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤.
        # "self.min_lfd","self.max_lfd", "self.lfd_gain" ì„ ë¯¸ë¦¬ ì •ì˜í•©ë‹ˆë‹¤.
        # ìµœì†Œ ìµœëŒ€ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°’ê³¼ ì†ë„ì— ë¹„ë¡€í•œ lfd_gain ê°’ì„ ì§ì ‘ ë³€ê²½í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        # ì´ˆê¸° ì •ì˜í•œ ë³€ìˆ˜ ë“¤ì˜ ê°’ì„ ë³€ê²½í•˜ë©° ì†ë„ì— ë¹„ë¡€í•´ì„œ ì „ë°©ì£¼ì‹œê±°ë¦¬ ê°€ ë³€í•˜ëŠ” advanced_purepursuit ì˜ˆì œë¥¼ ì™„ì„±í•˜ì„¸ìš”.
        
        self.lfd = self.lfd_gain * self.status_msg.velocity.x
        self.lfd = max(self.min_lfd, min(self.max_lfd, self.lfd))  # ìµœì†Œê°’ê³¼ ìµœëŒ€ê°’ ì‚¬ì´ì˜ ê°’ìœ¼ë¡œ ì¡°ì •
        rospy.loginfo(self.lfd)

        
        
        vehicle_position=self.current_postion
        self.is_look_forward_point= False

        translation = [vehicle_position.x, vehicle_position.y]

        # (3) ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
        
        # Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰ í•˜ê¸° ìœ„í•´ì„œ ì°¨ëŸ‰ ê¸°ì¤€ì˜ ì¢Œí‘œê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ í˜„ì¬ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œê³„ë¡œ ì¢Œí‘œ ë³€í™˜ì´ í•„ìš”í•©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì‘ì„±í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë³€í™˜ í›„ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì´ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•˜ê²Œ ë©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì´ìš©í•´ Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë°”ê¾¸ëŠ” ë°˜ë³µ ë¬¸ì„ ì‘ì„± í•œ ë’¤
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ê³„ì‚°í•˜ëŠ” ë¡œì§ì„ ì‘ì„± í•˜ì„¸ìš”.
        
        trans_matrix = np.array([[cos(self.vehicle_yaw),-sin(self.vehicle_yaw) ,0],
                                [sin(self.vehicle_yaw),cos(self.vehicle_yaw),0],
                                [0,0,1]])

        det_trans_matrix = np.linalg.inv(trans_matrix)

        for num,i in enumerate(self.path.poses) :
            path_point = i.pose.position

            global_path_point = [path_point.x - vehicle_position.x, path_point.y - vehicle_position.y, 1]
            local_path_point = det_trans_matrix.dot(global_path_point)    
            #print("g :", global_path_point)
            #print("l :", local_path_point)
            # if local_path_point[0]>0 :
            #     dis = sqrt(local_path_point[0]**2 + local_path_point[1]**2)
            #     if dis >= self.lfd :
            #         self.forward_point = local_path_point
            #         self.is_look_forward_point = True
            #         break
            if local_path_point[0] > 0:
                # ê°ë„ë¥¼ ê³„ì‚°í•˜ì—¬ ì •ë©´ì— ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
                angle_to_point = atan2(local_path_point[1], local_path_point[0])
                if abs(angle_to_point) < pi / 2:  # ì •ë©´ì— ìˆëŠ” ê²½ìš°ì—ë§Œ
                    dis = sqrt(local_path_point[0] ** 2 + local_path_point[1] ** 2)
                    if dis >= self.lfd:
                        self.forward_point = local_path_point
                        self.is_look_forward_point = True
                        break
        
        # (4) Steering ê°ë„ ê³„ì‚°
        
        # ì œì–´ ì…ë ¥ì„ ìœ„í•œ Steering ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # theta ëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ì¢Œí‘œì˜ ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # Steering ê°ë„ëŠ” Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì˜ ê°ë„ ê³„ì‚° ìˆ˜ì‹ì„ ì ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        theta = atan2(self.forward_point[1], self.forward_point[0])
        steering = atan2( ( 2 * self.vehicle_length * sin(theta)), sqrt(self.forward_point[0]**2 + self.forward_point[1]**2))

        return steering
    '''
    def calc_pure_pursuit(self,):

        #(2) ì†ë„ ë¹„ë¡€ Look Ahead Distance ê°’ ì„¤ì •
        '''
        # ì°¨ëŸ‰ ì†ë„ì— ë¹„ë¡€í•˜ì—¬ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°€ ë³€í•˜ëŠ” ìˆ˜ì‹ì„ êµ¬í˜„ í•©ë‹ˆë‹¤.
        # ì´ë•Œ 'self.lfd' ê°’ì€ ìµœì†Œì™€ ìµœëŒ€ ê°’ì„ ë„˜ì–´ì„œëŠ” ì•ˆë©ë‹ˆë‹¤.
        # "self.min_lfd","self.max_lfd", "self.lfd_gain" ì„ ë¯¸ë¦¬ ì •ì˜í•©ë‹ˆë‹¤.
        # ìµœì†Œ ìµœëŒ€ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ê°’ê³¼ ì†ë„ì— ë¹„ë¡€í•œ lfd_gain ê°’ì„ ì§ì ‘ ë³€ê²½í•´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        # ì´ˆê¸° ì •ì˜í•œ ë³€ìˆ˜ ë“¤ì˜ ê°’ì„ ë³€ê²½í•˜ë©° ì†ë„ì— ë¹„ë¡€í•´ì„œ ì „ë°©ì£¼ì‹œê±°ë¦¬ ê°€ ë³€í•˜ëŠ” advanced_purepursuit ì˜ˆì œë¥¼ ì™„ì„±í•˜ì„¸ìš”.
        # 
        self.lfd = 

        rospy.loginfo(self.lfd)

        '''
        self.lfd = self.lfd_gain * self.status_msg.velocity.x
        self.lfd = max(self.min_lfd, min(self.max_lfd, self.lfd))  # ìµœì†Œê°’ê³¼ ìµœëŒ€ê°’ ì‚¬ì´ì˜ ê°’ìœ¼ë¡œ ì¡°ì •
        rospy.loginfo(self.lfd)  # í˜„ì¬ lfd ê°’ ë¡œê·¸ë¡œ ì¶œë ¥

        
        vehicle_position=self.current_postion
        self.is_look_forward_point= False

        translation = [vehicle_position.x, vehicle_position.y]

        # (3) ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ ìƒì„±
        
        # Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰ í•˜ê¸° ìœ„í•´ì„œ ì°¨ëŸ‰ ê¸°ì¤€ì˜ ì¢Œí‘œê³„ê°€ í•„ìš”í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ í˜„ì¬ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œê³„ë¡œ ì¢Œí‘œ ë³€í™˜ì´ í•„ìš”í•©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ì„ ìœ„í•œ ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì‘ì„±í•©ë‹ˆë‹¤.
        # Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë³€í™˜ í›„ Pure Pursuit ì•Œê³ ë¦¬ì¦˜ ì¤‘ ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ì´ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•˜ê²Œ ë©ë‹ˆë‹¤.
        # ì¢Œí‘œ ë³€í™˜ í–‰ë ¬ì„ ì´ìš©í•´ Path ë°ì´í„°ë¥¼ ì°¨ëŸ‰ ê¸°ì¤€ ì¢Œí‘œ ê³„ë¡œ ë°”ê¾¸ëŠ” ë°˜ë³µ ë¬¸ì„ ì‘ì„± í•œ ë’¤
        # ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ë¥¼ ê³„ì‚°í•˜ëŠ” ë¡œì§ì„ ì‘ì„± í•˜ì„¸ìš”.

        trans_matrix = np.array([[cos(self.vehicle_yaw),-sin(self.vehicle_yaw) ,0],
                                [sin(self.vehicle_yaw),cos(self.vehicle_yaw),0],
                                [0,0,1]])

        det_trans_matrix = np.linalg.inv(trans_matrix)

        for num,i in enumerate(self.path.poses) :
            path_point = i.pose.position

            global_path_point = [path_point.x - vehicle_position.x, path_point.y - vehicle_position.y, 1]
            local_path_point = det_trans_matrix.dot(global_path_point)    
            #print("g :", global_path_point)
            #print("l :", local_path_point)
            # if local_path_point[0]>0 :
            #     dis = sqrt(local_path_point[0]**2 + local_path_point[1]**2)
            #     if dis >= self.lfd :
            #         self.forward_point = local_path_point
            #         self.is_look_forward_point = True
            #         break
            if local_path_point[0] > 0:
                # ê°ë„ë¥¼ ê³„ì‚°í•˜ì—¬ ì •ë©´ì— ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
                angle_to_point = atan2(local_path_point[1], local_path_point[0])
                if abs(angle_to_point) < pi / 2:  # ì •ë©´ì— ìˆëŠ” ê²½ìš°ì—ë§Œ
                    dis = sqrt(local_path_point[0] ** 2 + local_path_point[1] ** 2)
                    if dis >= self.lfd:
                        self.forward_point = local_path_point
                        self.is_look_forward_point = True
                        break


        
        # (4) Steering ê°ë„ ê³„ì‚°
        
        # ì œì–´ ì…ë ¥ì„ ìœ„í•œ Steering ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # theta ëŠ” ì „ë°©ì£¼ì‹œê±°ë¦¬(Look Forward Distance) ì™€ ê°€ì¥ ê°€ê¹Œìš´ Path Point ì¢Œí‘œì˜ ê°ë„ë¥¼ ê³„ì‚° í•©ë‹ˆë‹¤.
        # Steering ê°ë„ëŠ” Pure Pursuit ì•Œê³ ë¦¬ì¦˜ì˜ ê°ë„ ê³„ì‚° ìˆ˜ì‹ì„ ì ìš©í•˜ì—¬ ì¡°í–¥ ê°ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
        theta = atan2(self.forward_point[1], self.forward_point[0])

        # # ê°ë„ ë²”ìœ„ë¥¼ -Ï€ì—ì„œ Ï€ê¹Œì§€ë¡œ ì¡°ì •í•©ë‹ˆë‹¤.
        # if theta < -pi/2:
        #     theta += pi
        # elif theta > pi/2:
        #     theta -= pi

        steering = atan2( ( 2 * self.vehicle_length * sin(theta)), sqrt(self.forward_point[0]**2 + self.forward_point[1]**2))

        return steering  
    
    '''
    def calc_pure_pursuit(self):
        self.lfd = self.lfd_gain * self.status_msg.velocity.x
        self.lfd = max(self.min_lfd, min(self.max_lfd, self.lfd))  # ìµœì†Œê°’ê³¼ ìµœëŒ€ê°’ ì‚¬ì´ì˜ ê°’ìœ¼ë¡œ ì¡°ì •

        vehicle_position = self.current_postion
        self.is_look_forward_point = False

        translation = [vehicle_position.x, vehicle_position.y]

        # ì°¨ëŸ‰ì˜ í˜„ì¬ ë°©í–¥ ë²¡í„°
        vehicle_direction_vector = np.array([cos(self.vehicle_yaw), sin(self.vehicle_yaw)])

        # ê²½ë¡œ ìƒì˜ ëª¨ë“  ì ì— ëŒ€í•´ ê±°ë¦¬ì™€ ê°ë„ë¥¼ ê³„ì‚°í•˜ì—¬ ì „ë°© ì£¼ì‹œì ì„ ì°¾ìŒ
        min_distance = float('inf')
        for pose in self.path.poses:
            path_point = pose.pose.position
            path_point_vector = np.array([path_point.x - vehicle_position.x, path_point.y - vehicle_position.y])

            # ê²½ë¡œ ìƒì˜ ì ê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
            distance = np.linalg.norm(path_point_vector)

            # ì°¨ëŸ‰ ë°©í–¥ê³¼ ê²½ë¡œ ìƒì˜ ì  ì‚¬ì´ì˜ ê°ë„ ê³„ì‚°
            angle = np.arccos(np.dot(vehicle_direction_vector, path_point_vector) / (np.linalg.norm(vehicle_direction_vector) * np.linalg.norm(path_point_vector)))

            # ì „ë°© ì£¼ì‹œì  ì¡°ê±´ í™•ì¸
            if distance >= self.lfd and angle < pi / 2 and distance < min_distance:
                min_distance = distance
                self.forward_point = path_point
                self.is_look_forward_point = True

        if self.is_look_forward_point:
            # ì „ë°© ì£¼ì‹œì ê³¼ ì°¨ëŸ‰ ìœ„ì¹˜ ì‚¬ì´ì˜ ë²¡í„°
            forward_point_vector = np.array([self.forward_point.x - vehicle_position.x, self.forward_point.y - vehicle_position.y])
            # ì¡°í–¥ ê°ë„ ê³„ì‚°
            steering = atan2(2 * self.vehicle_length * forward_point_vector[1], forward_point_vector[0] ** 2 + forward_point_vector[1] ** 2)
        else:
            rospy.loginfo("No forward point found")
            steering = 0.0

        return steering
        '''


class pidControl:
    def __init__(self):
        self.p_gain = 0.3
        self.i_gain = 0.00
        self.d_gain = 0.03
        self.prev_error = 0
        self.i_control = 0
        self.controlTime = 0.02

    def pid(self,target_vel, current_vel):
        error = target_vel - current_vel

        # (5) PID ì œì–´ ìƒì„±
        
        # ì¢…ë°©í–¥ ì œì–´ë¥¼ ìœ„í•œ PID ì œì–´ê¸°ëŠ” í˜„ì¬ ì†ë„ì™€ ëª©í‘œ ì†ë„ ê°„ ì°¨ì´ë¥¼ ì¸¡ì •í•˜ì—¬ Accel/Brake ê°’ì„ ê²°ì • í•©ë‹ˆë‹¤.
        # ê° PID ì œì–´ë¥¼ ìœ„í•œ Gain ê°’ì€ "class pidContorl" ì— ì •ì˜ ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
        # ê° PID Gain ê°’ì„ ì§ì ‘ íŠœë‹í•˜ê³  ì•„ë˜ ìˆ˜ì‹ì„ ì±„ì›Œ ë„£ì–´ P I D ì œì–´ê¸°ë¥¼ ì™„ì„±í•˜ì„¸ìš”.
        p_control = self.p_gain * error
        self.i_control += self.i_gain * error * self.controlTime
        d_control = self.d_gain * ((error - self.prev_error) / self.controlTime)
        output = p_control + self.i_control + d_control
        self.prev_error = error

        return output

class velocityPlanning:
    def __init__ (self,car_max_speed, road_friciton):
        self.car_max_speed = car_max_speed
        self.road_friction = road_friciton

    def curvedBaseVelocity(self, gloabl_path, point_num):
        out_vel_plan = []

        for i in range(0,point_num):
            out_vel_plan.append(self.car_max_speed)

        for i in range(point_num, len(gloabl_path.poses) - point_num):
            x_list = []
            y_list = []
            for box in range(-point_num, point_num):
                x = gloabl_path.poses[i+box].pose.position.x
                y = gloabl_path.poses[i+box].pose.position.y
                x_list.append([-2*x, -2*y ,1])
                y_list.append((-x*x) - (y*y))

            # (6) ë„ë¡œì˜ ê³¡ë¥  ê³„ì‚°
            
            # ë„ë¡œì˜ ê³¡ë¥  ë°˜ê²½ì„ ê³„ì‚°í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì…ë‹ˆë‹¤.
            # Path ë°ì´í„°ì˜ ì¢Œí‘œë¥¼ ì´ìš©í•´ì„œ ê³¡ì„ ì˜ ê³¡ë¥ ì„ êµ¬í•˜ê¸° ìœ„í•œ ìˆ˜ì‹ì„ ì‘ì„±í•©ë‹ˆë‹¤.
            # ì›ì˜ ì¢Œí‘œë¥¼ êµ¬í•˜ëŠ” í–‰ë ¬ ê³„ì‚°ì‹, ìµœì†Œ ììŠ¹ë²•ì„ ì´ìš©í•˜ëŠ” ë°©ì‹ ë“± ê³¡ë¥  ë°˜ì§€ë¦„ì„ êµ¬í•˜ê¸° ìœ„í•œ ì‹ì„ ì ìš© í•©ë‹ˆë‹¤.
            # ì ìš©í•œ ìˆ˜ì‹ì„ í†µí•´ ê³¡ë¥  ë°˜ì§€ë¦„ "r" ì„ ê³„ì‚°í•©ë‹ˆë‹¤.

            A = np.array(x_list)
            B = np.array(y_list)
            result = np.linalg.lstsq(A, B, rcond=None)

            if len(result[0]) == 0:
                continue

            r = sqrt(result[0][0] ** 2 + result[0][1] ** 2)  # ê³¡ë¥  ë°˜ê²½ ê³„ì‚°
            gravityAcc = 9.8

            # (7) ê³¡ë¥  ê¸°ë°˜ ì†ë„ ê³„íš
            
            # ê³„ì‚° í•œ ê³¡ë¥  ë°˜ê²½ì„ ì´ìš©í•˜ì—¬ ìµœê³  ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤.
            # í‰í‰í•œ ë„ë¡œì¸ ê²½ìš° ìµœëŒ€ ì†ë„ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. 
            # ê³¡ë¥  ë°˜ê²½ x ì¤‘ë ¥ê°€ì†ë„ x ë„ë¡œì˜ ë§ˆì°° ê³„ìˆ˜ ê³„ì‚° ê°’ì˜ ì œê³±ê·¼ì´ ë©ë‹ˆë‹¤.
            v_max = sqrt(r * self.road_friction * gravityAcc)  # ìµœëŒ€ ì†ë„ ê³„íš
            print("r : " + str(r))
            print("friction : " + str(self.road_friction))
            print("gravityAcc : " + str(gravityAcc))
            print("v_max: " + str(v_max))
            print("\n")
            
            if v_max > self.car_max_speed:
                v_max = self.car_max_speed
            out_vel_plan.append(v_max)

        for i in range(len(gloabl_path.poses) - point_num, len(gloabl_path.poses)-10):
            out_vel_plan.append(30)

        for i in range(len(gloabl_path.poses) - 10, len(gloabl_path.poses)):
            out_vel_plan.append(0)

        return out_vel_plan

class AdaptiveCruiseControl:
    def __init__(self, velocity_gain, distance_gain, time_gap, vehicle_length):
        self.npc_vehicle=[False,0]
        self.object=[False,0]
        self.Person=[False,0]
        self.velocity_gain = velocity_gain
        self.distance_gain = distance_gain
        self.time_gap = time_gap
        self.vehicle_length = vehicle_length

        self.object_type = None
        self.object_distance = 0
        self.object_velocity = 0

    def check_object(self,ref_path, global_npc_info, local_npc_info, 
                                    global_ped_info, local_ped_info, 
                                    global_obs_info, local_obs_info):
        # (8) ê²½ë¡œìƒì˜ ì¥ì• ë¬¼ ìœ ë¬´ í™•ì¸ (ì°¨ëŸ‰, ì‚¬ëŒ, ì •ì§€ì„  ì‹ í˜¸)
        
        # ì£¼í–‰ ê²½ë¡œ ìƒì˜ ì¥ì• ë¬¼ì˜ ìœ ë¬´ë¥¼ íŒŒì•…í•©ë‹ˆë‹¤.
        # ì¥ì• ë¬¼ì´ í•œê°œ ì´ìƒ ìˆë‹¤ë©´ self.object ë³€ìˆ˜ì˜ ì²«ë²ˆì§¸ ê°’ì„ True ë¡œ ë‘¡ë‹ˆë‹¤.
        # ì¥ì• ë¬¼ì˜ ëŒ€í•œ ì •ë³´ëŠ” List í˜•ì‹ìœ¼ë¡œ self.object ë³€ìˆ˜ì˜ ë‘ë²ˆì§¸ ê°’ìœ¼ë¡œ ë‘¡ë‹ˆë‹¤.
        # ì¥ì• ë¬¼ì˜ ìœ ë¬´ íŒë‹¨ì€ ì£¼í–‰ í•  ê²½ë¡œì—ì„œ ì–¼ë§ˆë‚˜ ë–¨ì–´ì ¸ ìˆëŠ”ì§€ë¥¼ ë³´ê³  íŒë‹¨ í•©ë‹ˆë‹¤.
        # ì•„ë˜ ì˜ˆì œëŠ” ì£¼í–‰ ê²½ë¡œì—ì„œ Object ê¹Œì§€ì˜ ê±°ë¦¬ë¥¼ íŒŒì•…í•˜ì—¬ 
        # ê²½ë¡œë¥¼ ê¸°ì¤€ìœ¼ë¡œ 2.5 m ì•ˆìª½ì— ìˆë‹¤ë©´ ì£¼í–‰ ê²½ë¡œ ë‚´ ì¥ì• ë¬¼ì´ ìˆë‹¤ê³  íŒë‹¨ í•©ë‹ˆë‹¤.
        # ì£¼í–‰ ê²½ë¡œ ìƒ ì¥ì• ë¬¼ì´ ì—¬ëŸ¬ê²Œ ìˆëŠ” ê²½ìš° ê°€ì¥ ê°€ê¹Œì´ ìˆëŠ” ì¥ì• ë¬¼ ì •ë³´ë¥¼ ê°€ì§€ë„ë¡ í•©ë‹ˆë‹¤.

        

        
        # ì£¼í–‰ ê²½ë¡œ ìƒ ë³´í–‰ì ìœ ë¬´ íŒŒì•…
        min_rel_distance=float('inf')
        if len(global_ped_info) > 0 :        
            for i in range(len(global_ped_info)):
                for path in ref_path.poses :      
                    if global_ped_info[i][0] == 0 : # type=0 [pedestrian]                    
                        ped_x = global_ped_info[i][1]
                        ped_y = global_ped_info[i][2]
                        path_x = path.pose.position.x
                        path_y = path.pose.position.y
                        dis = ((ped_x - path_x) ** 2 + (ped_y - path_y) ** 2) ** 0.5  # ì£¼ì–´ì§„ ì¥ì• ë¬¼ê³¼ í˜„ì¬ ê²½ë¡œ ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
                        if dis<2.35:                            
                            rel_distance = dis  # ì¥ì• ë¬¼ê¹Œì§€ì˜ ìƒëŒ€ì  ê±°ë¦¬
                            if rel_distance < min_rel_distance:
                                min_rel_distance = rel_distance
                                self.Person=[True,i]

        

        
        # ì£¼í–‰ ê²½ë¡œ ìƒ NPC ì°¨ëŸ‰ ìœ ë¬´ íŒŒì•…
        if len(global_npc_info) > 0 :            
            for i in range(len(global_npc_info)):
                for path in ref_path.poses :      
                    if global_npc_info[i][0] == 1 : # type=1 [npc_vehicle] 
                        npc_x, npc_y = global_npc_info[i][1], global_npc_info[i][2]
                        path_x, path_y = path.pose.position.x, path.pose.position.y
                        dis = ((npc_x - path_x) ** 2 + (npc_y - path_y) ** 2) ** 0.5
                        if dis<2.35:
                            rel_distance =  rel_distance = dis  # ì¥ì• ë¬¼ê¹Œì§€ì˜ ìƒëŒ€ì  ê±°ë¦¬      
                            if rel_distance < min_rel_distance:
                                min_rel_distance = rel_distance
                                self.npc_vehicle=[True,i]
        
        

        
        # ì£¼í–‰ ê²½ë¡œ ìƒ Obstacle ìœ ë¬´ íŒŒì•…
        # acc ì˜ˆì œëŠ” ì£¼í–‰ ì¤‘ ì „ë°©ì— ì°¨ëŸ‰ì— ì†ë„ì— ë§ì¶° ì›€ì§ì´ë„ë¡ í•˜ëŠ” Cruise Control
        # ì˜ˆì œ ì´ê¸° ë•Œë¬¸ì— ì •ì  ì¥ì• ë¬¼(Obstacle) ì˜ ì •ë³´ëŠ” ë°›ì§€ ì•ŠëŠ”ê²Œ ì¢‹ìŠµë‹ˆë‹¤.
        # ì •ì  ì¥ì• ë¬¼ì€ ì›€ì§ì´ì§€ ì•Šê¸° ë•Œë¬¸ì— Cruise Control ì•Œê³ ë¦¬ì¦˜ ìƒ
        # ì •ì  ì¥ì• ë¬¼ì„ ë§Œë‚˜ê²Œ ë˜ë©´ ì†ë„ê°€ 0ì¸ ì •ì  ì¥ì• ë¬¼ ë°”ë¡œ ë’¤ì— ì •ì§€í•˜ê²Œ ë©ë‹ˆë‹¤.
        if len(global_obs_info) > 0 :            
            for i in range(len(global_obs_info)):
                for path in ref_path.poses :      
                    if global_obs_info[i][0] == 2 : # type=1 [obstacle] 
                        obs_x, obs_y = global_obs_info[i][1], global_obs_info[i][2]
                        path_x, path_y = path.pose.position.x, path.pose.position.y
                        dis = ((obs_x - path_x) ** 2 + (obs_y - path_y) ** 2) ** 0.5
                        if dis<2.35:
                            rel_distance= rel_distance = dis  # ì¥ì• ë¬¼ê¹Œì§€ì˜ ìƒëŒ€ì  ê±°ë¦¬               
                            if rel_distance < min_rel_distance:
                                min_rel_distance = rel_distance
                                self.object=[True,i] 
        
        

    def get_target_velocity(self, local_npc_info, local_ped_info, local_obs_info, ego_vel, target_vel): 

        
        # (9) ì¥ì• ë¬¼ê³¼ì˜ ì†ë„ì™€ ê±°ë¦¬ ì°¨ì´ë¥¼ ì´ìš©í•˜ì—¬ ACC ë¥¼ ì§„í–‰ ëª©í‘œ ì†ë„ë¥¼ ì„¤ì •
        out_vel =  target_vel
        default_space = 8
        time_gap = self.time_gap
        v_gain = self.velocity_gain
        x_errgain = self.distance_gain

        if self.npc_vehicle[0] and len(local_npc_info) != 0: #ACC ON_vehicle   
            print("ACC ON NPC_Vehicle")         
            front_vehicle = [local_npc_info[self.npc_vehicle[1]][1], local_npc_info[self.npc_vehicle[1]][2], local_npc_info[self.npc_vehicle[1]][3]]
            
            dis_safe = ego_vel * time_gap + default_space
            dis_rel = sqrt(pow(front_vehicle[0],2) + pow(front_vehicle[1],2))            
            vel_rel=((front_vehicle[2] / 3.6) - ego_vel)                        
            acceleration = vel_rel * v_gain - x_errgain * (dis_safe - dis_rel)

            out_vel = ego_vel + acceleration      

        if self.Person[0] and len(local_ped_info) != 0: #ACC ON_Pedestrian
            print("ACC ON Pedestrian")
            Pedestrian = [local_ped_info[self.Person[1]][1], local_ped_info[self.Person[1]][2], local_ped_info[self.Person[1]][3]]
            
            dis_safe = ego_vel* time_gap + default_space
            dis_rel = sqrt(pow(Pedestrian[0],2) + pow(Pedestrian[1],2))            
            vel_rel = (Pedestrian[2] - ego_vel)              
            acceleration = vel_rel * v_gain - x_errgain * (dis_safe - dis_rel)    

            out_vel = ego_vel + acceleration
   
        if self.object[0] and len(local_obs_info) != 0: #ACC ON_obstacle     
            print("ACC ON Obstacle")                    
            Obstacle = [local_obs_info[self.object[1]][1], local_obs_info[self.object[1]][2], local_obs_info[self.object[1]][3]]
            
            dis_safe = ego_vel* time_gap + default_space
            dis_rel = sqrt(pow(Obstacle[0],2) + pow(Obstacle[1],2))            
            vel_rel = (Obstacle[2] - ego_vel)
            acceleration = vel_rel * v_gain - x_errgain * (dis_safe - dis_rel)    

            out_vel = ego_vel + acceleration           
        print("HI OBJ VEL")
        return out_vel * 3.6


if __name__ == '__main__':
    try:
        test_track=pure_pursuit()
    except rospy.ROSInterruptException:
        pass


```